# 10 Overloaded Operator

!!! tip "说明"

    本文档正在更新中……

!!! info "说明"

    本文档仅涉及部分内容，仅可用于复习重点知识

## 1 概念

运算符重载是 C++ 提供的一种功能，允许程序员为用户定义的类型（如类或结构体）重新定义标准运算符的行为

- 目的：使用户定义的类型能够像内置类型一样使用运算符
- 限制：不能创建新的运算符，只能重载已有的运算符

运算符重载通过定义一个特殊的成员函数或友元函数实现

1. 成员函数形式：运算符作为类的成员函数时，左操作数必须是类的对象。`ReturnType operatorOp(Arguments);`
2. 友元（全局）函数形式：运算符作为友元函数时，可以访问类的私有成员，且左操作数不必是类的对象。`friend ReturnType operatorOp(Arguments);`

可重载的运算符：

1. 算术运算符：`+`, `-`, `*`, `/`, `%`
2. 关系运算符：`==`, `!=`, `<`, `>`, `<=`, `>=`
3. 逻辑运算符：`&&`, `||`, `!`
4. 位运算符：`&`, `|`, `^`, `~`, `<<`, `>>`
5. 赋值运算符：`=`, `+=`, `-=`, `*=`, `/=`, `%=`, `<<=`, `>>=`, `&=`, `|=`, `^=`
6. 类型转换运算符：`Type()`
7. 其他运算符：`++`, `--`, `[]`, `()`, `->`, `->*`, `new`, `delete`

不可重载的运算符：

1. `::`（作用域解析运算符）
2. `.*`（成员指针访问运算符）
3. `.`（成员访问运算符）
4. `?:`
5. `sizeof`（大小运算符）
6. `typeid`（类型信息运算符）
7. `static_cast`, `dynamic_cast` 等（类型转换）

注意事项：

1. 不能改变运算符的优先级和结合性：运算符的优先级和结合性是固定的，无法通过重载改变
2. 避免滥用运算符重载：运算符重载应符合直觉，避免引入令人困惑的行为
3. 返回值类型：

    1. 对于赋值运算符（如 `=`），应返回当前对象的引用（`*this`）
    2. 对于算术运算符（如 `+`），通常返回一个新对象

4. 自定义赋值运算符时注意自赋值：在实现赋值运算符时，应检查 `this == &other`，以避免自赋值导致的问题

| 运算符类别 | 运算符 | 可重载类型 | 通常返回类型 | 备注 |
|---|---|---|---|---|
| 算术运算符 | `+`, `-`, `*`, `/`, `%` | 成员或友元 | 新对象（如`T`或`const T`） | 通常返回新对象，不修改操作数 |
| | `+`（正）, `-`（负） | 成员 | `T`或`const T` | 一元运算符，成员函数无参数 |
| 自增/自减 | `++a`（前置） | 成员 | `T&` | 返回修改后的对象引用 |
| | `a++`（后置） | 成员 | `T`（旧值副本） | 需添加 `int` 哑参数区分（如 `operator++(int)`）|
| | `--a`（前置） | 成员 | `T&` | 同前置++ |
| | `a--`（后置） | 成员 | `T`（旧值副本） | 需添加 `int` 哑参数（如 `operator--(int)`）|
| 关系运算符 | `==`, `!=`, `<`, `>`, `<=`, `>=` | 成员或友元 | `bool` | 通常成对重载（如`==`和`!=`）|
| 逻辑运算符 | `&&`, `\|\|` | 成员或友元 | `bool` | 短路行为可能丢失，谨慎使用 |
| | `!` | 成员 | `bool` | 一元运算符 |
| 位运算符 | `&`, `\|`, `^` | 成员或友元 | 新对象（如`T`）| 按位操作 |
| | `~` | 成员 | `T` | 一元运算符（按位取反）|
| | `<<`, `>>` | 友元 | `ostream&`/`istream&`  | 输入输出流操作符通常为友元  |
| 赋值运算符 | `=`| 成员 | `T&` | 返回当前对象的引用（支持链式赋值）|
| | `+=`, `-=`, `*=`, `/=`, `%=` 等复合赋值 | 成员 | `T&` | 修改当前对象并返回引用 |
| 类型转换运算符 | `Type()` | 成员 | 任意目标类型| 无返回类型声明（如 `operator int() const`）|
| 其他运算符 | `[]` | 成员 | `T&` 或 `const T&` | 需重载`const`和非`const`版本|
| | `()`| 成员 | 任意类型 | 函数对象（仿函数） |
| | `->`, `->*`| 成员 | 指针或代理对象| 用于智能指针或迭代器 |
| | `new`, `delete`| 成员（静态）| `void*`（`new`）, `void`（`delete`） | 静态成员函数，即使不显式声明 |
| | `,`（逗号）| 成员或友元| 任意类型 | 不推荐重载（易混淆） |
| | `&`（取地址）| 成员 | 指针类型 | 极少需要重载  |

!!! tip "建议"

    1. 对称运算符（如 `+`, `==`）推荐用全局函数：支持 `a + b` 和 `b + a` 的互换性
    2. 复合赋值运算符（如 `+=`）用成员函数：直接修改对象状态
    3. 输入/输出运算符（`<<`, `>>`）必须全局函数：因为左操作数是流对象

## 2 运算符重载的实现

### 2.1 重载算术运算符

```cpp linenums="1"
#include <iostream>
using namespace std;

class Complex {
private:
    double real, imag;

public:
    Complex(double r = 0, double i = 0) : real(r), imag(i) {}

    // 重载加法运算符（成员函数形式）
    Complex operator+(const Complex& other) const {
        return Complex(real + other.real, imag + other.imag);
    }

    void display() const {
        cout << real << " + " << imag << "i" << endl;
    }
};

int main() {
    Complex c1(1.0, 2.0), c2(3.0, 4.0);
    Complex c3 = c1 + c2; // 调用重载的 +
    c3.display();
    return 0;
}
```

```cpp linenums="1" title="output"
4 + 6i
```

### 2.2 重载关系运算符

```cpp linenums="1"
#include <iostream>
using namespace std;

class Box {
private:
    double volume;

public:
    Box(double v) : volume(v) {}

    // 重载小于运算符（友元函数形式）
    friend bool operator<(const Box& b1, const Box& b2) {
        return b1.volume < b2.volume;
    }
};

int main() {
    Box b1(10.0), b2(20.0);
    if (b1 < b2) {
        cout << "b1 is smaller than b2" << endl;
    }
    return 0;
}
```

```cpp linenums="1" title="output"
b1 is smaller than b2
```

### 2.3 重载输入/输出运算符

输入/输出运算符通常以友元函数形式重载

```cpp linenums="1"
#include <iostream>
using namespace std;

class Point {
private:
    int x, y;

public:
    Point(int x = 0, int y = 0) : x(x), y(y) {}

    // 重载输出运算符
    friend ostream& operator<<(ostream& os, const Point& p) {
        os << "(" << p.x << ", " << p.y << ")";
        return os;
    }

    // 重载输入运算符
    friend istream& operator>>(istream& is, Point& p) {
        is >> p.x >> p.y;
        return is;
    }
};

int main() {
    Point p1, p2;
    cout << "Enter coordinates for p1: ";
    cin >> p1;
    cout << "p1: " << p1 << endl;

    return 0;
}
```

```cpp linenums="1" title="input"
Enter coordinates for p1: 3 4
```

```cpp linenums="1" title="output"
p1: (3, 4)
```

### 2.4 重载下标运算符

下标运算符 `[]` 通常以成员函数形式重载

```cpp linenums="1"
#include <iostream>
using namespace std;

class Array {
private:
    int arr[10];

public:
    Array() {
        for (int i = 0; i < 10; ++i) arr[i] = i;
    }

    // 重载下标运算符
    int& operator[](int index) {
        return arr[index];
    }
};

int main() {
    Array a;
    a[2] = 42; // 使用重载的 []
    cout << "a[2] = " << a[2] << endl;
    return 0;
}
```

```cpp linenums="1" title="output"
a[2] = 42
```

### 2.5 重载函数调用运算符

函数调用运算符 `()` 可以重载，使对象像函数一样调用

```cpp linenums="1"
#include <iostream>
using namespace std;

class Multiply {
public:
    int operator()(int a, int b) {
        return a * b;
    }
};

int main() {
    Multiply multiply;
    cout << "3 * 4 = " << multiply(3, 4) << endl; // 使用重载的 ()
    return 0;
}
```

```cpp linenums="1" title="output"
3 * 4 = 12
```

### 2.6 特殊运算符的重载

**1.赋值运算符 `=`**

```cpp linenums="1"
class MyClass {
public:
    MyClass& operator=(const MyClass& other) {
        if (this == &other) return *this; // 防止自赋值
        // 赋值逻辑
        return *this;
    }
};
```

**2.自增/自减运算符 `++` 和 `--`**

```cpp linenums="1" title="前置版本"
MyClass& operator++() {
    // 前置自增逻辑
    return *this;
}
```

```cpp linenums="1" title="后置版本"
MyClass operator++(int) {
    MyClass temp = *this;
    // 后置自增逻辑
    return temp;
}
```