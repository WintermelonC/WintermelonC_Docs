# 11 Template

<!-- !!! tip "说明"

    本文档正在更新中…… -->

!!! info "说明"

    本文档仅涉及部分内容，仅可用于复习重点知识

**模板**（Template）是一种通用编程工具，用于编写与类型无关的代码。模板允许开发者编写可以处理多种数据类型的函数或类，而无需为每种类型重复编写代码。C++ 支持两种主要的模板：**函数模板** 和 **类模板**

模板的核心思想是将类型参数化。通过模板，类型可以作为参数传递给函数或类，从而实现代码的复用和泛型编程（generic programming）

模板的语法：

```cpp linenums="1"
template <typename T>
// 或
template <class T>
```

1. `typename` 和 `class` 在模板中是等价的，表示类型参数
2. `T` 是类型参数的占位符，可以是任何合法的标识符

模板的注意事项

1. 模板的实例化：

    1. 模板代码只有在使用时才会被实例化为具体的类型
    2. 编译器会为每种使用的类型生成对应的代码

2. 模板的代码膨胀：如果模板被用于多种类型，可能会导致代码膨胀（生成大量重复代码）
3. 模板的定义与实现：模板的定义和实现通常放在同一个头文件中，因为模板的实例化需要在编译时完成
4. 模板的调试：模板代码的错误信息可能较难理解，尤其是涉及复杂的模板嵌套时

!!! tip "模板类的实现文件分离问题"

    在实际开发中，模板类的声明和定义通常放在同一个头文件中，而不是将定义放在 `.cpp` 文件中。这是因为模板的实例化需要在编译时完成，而模板的定义必须在使用时可见

    解决方法：

    1. 将模板类的声明和定义都放在头文件中
    2. 或者，将模板类的定义放在一个 `.hpp` 文件中，并在头文件中包含它

    === "MyClass.h"

        ```cpp linenums="1"
        #ifndef MYCLASS_H
        #define MYCLASS_H
        
        #include <iostream>
        using namespace std;
        
        template <typename T>
        class MyClass {
        private:
            T value;
        public:
            MyClass(T v);
            void display() const;
        };
        
        #include "MyClass.hpp" // 包含实现文件
        #endif
        ```

    === "MyClass.hpp"

        ```cpp linenums="1"
        template <typename T>
        MyClass<T>::MyClass(T v) : value(v) {}
        
        template <typename T>
        void MyClass<T>::display() const {
            cout << "Value: " << value << endl;
        }
        ```

    === "main.cpp"

        ```cpp linenums="1"
        #include "MyClass.h"
        
        int main() {
            MyClass<int> obj(42);
            obj.display(); // 输出: Value: 42
            return 0;
        }
        ```

## 1 Function Template

函数模板用于定义可以处理多种类型的函数。编译器会根据调用时的参数类型生成具体的函数

```cpp linenums="1"
#include <iostream>
using namespace std;

template <typename T>
T add(T a, T b) {
    return a + b;
}

int main() {
    cout << add(3, 5) << endl;       // 输出: 8 (int 类型)
    cout << add(2.5, 3.5) << endl;  // 输出: 6.0 (double 类型)
    return 0;
}
```

如果需要为特定类型提供不同的实现，可以使用 `模板特化`

```cpp linenums="1"
#include <iostream>
using namespace std;

template <typename T>
T add(T a, T b) {
    return a + b;
}

// 针对 const char* 类型的特化
template <>
const char* add(const char* a, const char* b) {
    return "String concatenation not supported";
}

int main() {
    cout << add(3, 5) << endl;       // 输出: 8
    cout << add("Hello", "World") << endl; // 输出: String concatenation not supported
    return 0;
}
```

## 2 Class Template

类模板用于定义可以处理多种类型的类。编译器会根据使用时的类型生成具体的类

```cpp linenums="1"
#include <iostream>
using namespace std;

template <typename T>
class Box {
private:
    T value;
public:
    Box(T v) : value(v) {}
    T getValue() const { return value; }
};

int main() {
    Box<int> intBox(42);       // 使用 int 类型
    Box<double> doubleBox(3.14); // 使用 double 类型

    cout << intBox.getValue() << endl;    // 输出: 42
    cout << doubleBox.getValue() << endl; // 输出: 3.14
    return 0;
}
```

与函数模板类似，类模板也可以为特定类型提供特化实现

```cpp linenums="1"
#include <iostream>
using namespace std;

template <typename T>
class Box {
private:
    T value;
public:
    Box(T v) : value(v) {}
    T getValue() const { return value; }
};

// 针对 const char* 类型的特化
template <>
class Box<const char*> {
private:
    const char* value;
public:
    Box(const char* v) : value(v) {}
    const char* getValue() const { return value; }
};

int main() {
    Box<int> intBox(42);
    Box<const char*> strBox("Hello");

    cout << intBox.getValue() << endl;    // 输出: 42
    cout << strBox.getValue() << endl;   // 输出: Hello
    return 0;
}
```

如果类模板的成员函数的声明在类内，而定义在类外，需要在定义时使用模板的完整语法，包括 `template` 关键字和模板参数列表。此外，还需要在类名后加上模板参数列表来表明这是一个模板类的成员函数

```cpp linenums="1"
#include <iostream>
using namespace std;

// 声明类模板
template <typename T1, typename T2>
class MyPair {
private:
    T1 first;
    T2 second;
public:
    MyPair(T1 f, T2 s); // 构造函数声明
    void display() const; // 成员函数声明
};

// 定义构造函数
template <typename T1, typename T2>
MyPair<T1, T2>::MyPair(T1 f, T2 s) : first(f), second(s) {}

// 定义成员函数
template <typename T1, typename T2>
void MyPair<T1, T2>::display() const {
    cout << "First: " << first << ", Second: " << second << endl;
}

int main() {
    MyPair<int, double> pair(42, 3.14);
    pair.display(); // 输出: First: 42, Second: 3.14

    MyPair<string, int> pair2("Age", 25);
    pair2.display(); // 输出: First: Age, Second: 25

    return 0;
}
```

1. 在类外定义成员函数时，必须再次使用 `template <typename T>` 来表明这是一个模板
2. 在类名后使用 `MyClass<T>`，其中 `<T>` 表示模板参数

## 3 模板的高级用法

### 3.1 非类型模板参数

模板参数不仅可以是类型，还可以是常量（如整数、指针等）

```cpp linenums="1"
#include <iostream>
using namespace std;

template <typename T, int size>
class Array {
private:
    T arr[size];
public:
    void set(int index, T value) {
        if (index >= 0 && index < size) {
            arr[index] = value;
        }
    }
    T get(int index) const {
        return arr[index];
    }
};

int main() {
    Array<int, 5> intArray;
    intArray.set(0, 42);
    cout << intArray.get(0) << endl; // 输出: 42
    return 0;
}
```

### 3.2 模板的默认参数

模板参数可以有默认值

```cpp linenums="1"
#include <iostream>
using namespace std;

template <typename T = int>
class Box {
private:
    T value;
public:
    Box(T v) : value(v) {}
    T getValue() const { return value; }
};

int main() {
    Box<> intBox(42); // 使用默认类型 int
    Box<double> doubleBox(3.14);

    cout << intBox.getValue() << endl;    // 输出: 42
    cout << doubleBox.getValue() << endl; // 输出: 3.14
    return 0;
}
```

### 3.3 模板的嵌套

模板可以嵌套使用，例如类模板中包含另一个模板

```cpp linenums="1" hl_lines="8"
#include <iostream>
#include <vector>
using namespace std;

template <typename T>
class Container {
private:
    vector<T> elements;
public:
    void add(T element) {
        elements.push_back(element);
    }
    void display() const {
        for (const auto& elem : elements) {
            cout << elem << " ";
        }
        cout << endl;
    }
};

int main() {
    Container<int> intContainer;
    intContainer.add(1);
    intContainer.add(2);
    intContainer.add(3);
    intContainer.display(); // 输出: 1 2 3
    return 0;
}
```

## 4 Template and Inheritance

### 4.1 模板类作为基类

模板类可以作为基类，派生类可以是普通类或模板类

```cpp linenums="1" title="普通类继承模板类"
#include <iostream>
using namespace std;

// 定义模板基类
template <typename T>
class Base {
protected:
    T value;
public:
    Base(T v) : value(v) {}
    void display() const {
        cout << "Base value: " << value << endl;
    }
};

// 定义普通派生类
class Derived : public Base<int> {
public:
    Derived(int v) : Base<int>(v) {}
    void show() const {
        // 派生类 Derived 可以直接使用基类的成员
        cout << "Derived value: " << value << endl;
    }
};

int main() {
    Derived d(42);
    d.display(); // 调用基类方法
    d.show();    // 调用派生类方法
    return 0;
}
```

```cpp linenums="1" title="模板类继承模板类"
#include <iostream>
using namespace std;

// 定义模板基类
template <typename T>
class Base {
protected:
    T value;
public:
    Base(T v) : value(v) {}
    void display() const {
        cout << "Base value: " << value << endl;
    }
};

// 定义模板派生类
template <typename T>
class Derived : public Base<T> {
public:
    Derived(T v) : Base<T>(v) {}
    void show() const {
        // 在派生类中，必须通过 Base<T>:: 或 this-> 来访问基类的成员
        cout << "Derived value: " << this->value << endl;
    }
};

int main() {
    Derived<int> d(42);
    d.display(); // 调用基类方法
    d.show();    // 调用派生类方法
    return 0;
}
```

### 4.2 模板类作为派生类

模板类可以继承普通类或模板类

```cpp linenums="1" title="模板类继承普通类"
#include <iostream>
using namespace std;

// 定义普通基类
class Base {
protected:
    int value;
public:
    Base(int v) : value(v) {}
    void display() const {
        cout << "Base value: " << value << endl;
    }
};

// 定义模板派生类
template <typename T>
class Derived : public Base {
private:
    T extraValue;
public:
    Derived(int v, T ev) : Base(v), extraValue(ev) {}
    void show() const {
        cout << "Base value: " << value << ", Extra value: " << extraValue << endl;
    }
};

int main() {
    Derived<double> d(42, 3.14);
    d.display(); // 调用基类方法
    d.show();    // 调用派生类方法
    return 0;
}
```