# 5 Undecidability

<!-- !!! tip "说明"

    本文档正在更新中…… -->

!!! warning "注意"

    我把这一章放掉了，只把结论记住了。请同学们不要看这个文档

## 1 The Church-Turing Thesis

!!! quote "课本原文 AI 翻译"

    在这本书中，我们探讨了这样一个问题：什么是可以被计算的？（更有趣的是，什么是不能被计算的？）我们已经介绍了各种各样的计算过程的数学模型，这些模型能够完成具体的计算任务——特别是判定、半判定或生成语言，以及计算函数。在上一章中，我们看到图灵机可以执行这类令人惊讶的复杂任务。我们也看到，某些可以添加到基本图灵机模型中的附加特性（包括随机访问能力），并不会增加可完成的任务集合。此外，沿着一条完全不同的路径（即尝试推广上下文无关文法），我们得到了一类语言生成器，其能力恰好与图灵机相同。最后，通过试图形式化我们关于哪些数值函数可以被视为可计算的直觉，我们定义了一类函数，结果发现它们恰好是递归函数
    
    所有这一切表明，我们已经达到了计算设备所能设计完成任务的自然上限；我们对计算过程、算法这一终极且最一般化的数学概念的探索，已成功结束——而图灵机正是正确的答案。然而，我们在上一章也看到，并非所有的图灵机都值得被称为“算法”。我们认为，那些只能半判定语言（因此可能永远不会停止）的图灵机并不是有用的计算设备，而那些能判定语言并计算函数（因此在所有输入上都会停止）的图灵机才是。我们的“算法”概念必须排除那些在某些输入上可能不会停止的图灵机
    
    因此，我们提议采用在所有输入上都会停止的图灵机，作为与“算法”这一直观概念相对应的精确形式化定义。如果某个过程无法被表示为一种在所有输入上都能保证停止的图灵机，那么它就不能被视为一个算法；而所有这样的图灵机都应被恰当地称为算法。这一原则被称为 **Church-Turing thesis**（丘奇-图灵论题）。这是一条论题，而非定理，因为它不是一个数学结果：它仅仅断言一个非正式的直觉概念（即“算法”）对应于某种特定的数学对象（即图灵机）。由于它不是数学命题，因此丘奇-图灵论题无法被证明。然而，理论上存在这样一种可能性：未来某一天，如果有人提出了一种新的计算模型，该模型被公认为合理且可信的计算模型，并且能够完成某些图灵机无法实现的计算，那么丘奇-图灵论题就可能被推翻。不过，没有人认为这种情形是可能发生的
    
    采用一个精确的算法数学定义，开启了这样一个引人入胜的可能性：可以形式化地证明某些计算问题根本无法通过任何算法解决。我们已经知道这一点是可以预期的。在第一章中，我们曾论证过：如果用字符串来表示语言，那么并非所有语言都可以被表示出来——因为在一个字母表上的字符串只有可数无穷多个，而语言的数量却是不可数无穷多。有限自动机、下推自动机、上下文无关文法、无限制文法以及图灵机都是可用于指定语言的有限对象的例子，而且这些对象本身也可以用字符串来描述（在下一节中，我们将详细阐述如何用字符串表示图灵机）。因此，对于任意一个字母表，只存在可数无穷多个递归语言和递归可枚举语言。所以尽管我们已竭尽全力扩展计算机器的能力，但从绝对意义上讲，它们只能用于半判定或判定所有可能语言中微乎其微的一小部分
    
    使用基数论（cardinality）的论证来说明我们方法的局限性是平凡的；而找到在某个模型中无法完成的具体计算任务的例子则更加有趣且富有意义。在前面的章节中，我们成功地找到了某些不是正则语言或上下文无关语言的语言；在本章中，我们将对递归语言做同样的工作。然而，这里有两点主要的不同之处。首先，这些新的负面结果不仅仅是暂时的挫折，它们将在后续章节中被克服，届时将定义一种更强大的计算设备：根据丘奇-图灵论题，不能由图灵机执行的计算任务是不可行的、无望的、不可判定的。其次，我们用来证明某种语言不是递归语言的方法必须不同于之前用于揭示上下文无关文法和有限自动机弱点的“抽屉”定理（pumping theorems）。相反，我们需要设计出一些技术，以利用图灵机本身所具有的强大能力，从而揭示其自身的局限性。我们将要探讨的图灵机能力的一个方面，是一种“内省能力”（introspective ability）：我们指出，图灵机可以接收图灵机的编码作为输入，并以有趣的方式操纵这些编码。接下来我们将探讨当一台图灵机操作它自身编码时会发生什么——这是对对角化原理（diagonalization principle）的一种巧妙而又简单的应用。如何对一台图灵机进行编码，以便它能被另一台（或者同一台！）图灵机所操纵，这正是我们接下来要讨论的主题

    **Church-Turing Thesis**（丘奇-图灵论题）是计算理论中的一个核心假设，它试图形式化“什么是可以被有效计算的”这一直观概念。虽然它被称为“论题”（thesis）而非“定理”（theorem），因为它无法被严格数学证明（其基础涉及非形式化的直觉概念），但它在计算机科学和数学逻辑中具有基石地位
    
    丘奇-图灵论题的核心思想可以简洁地表述为：任何在算法上可计算的函数，都可以由图灵机计算。换句话说：如果某个问题能通过“机械步骤”（即算法）在有限时间内解决，那么就存在一台图灵机可以在输入该问题时输出正确答案

## 2 Universal Turing Machines

!!! quote "课本原文 AI 翻译"

    计算的基础是硬件还是软件？你可能对这个问题有自己的看法——以及关于这个问题是否有意义、是否具有建设性。但事实是，我们在上一章中引入并发展的算法形式化模型——图灵机——是一种“不可编程”的硬件，专门用于解决某个特定问题，其指令在出厂时就已经“硬编码”（hard-wired）
    
    现在我们将从相反的角度来看待这个问题。我们将论证：图灵机也是软件。也就是说，我们将证明存在一种“通用”的图灵机，它能够像通用计算机一样被编程，从而解决任何图灵机可以解决的问题。使这种通用机器表现出特定机器 $M$ 行为的“程序”，必须是 $M$ 的一种描述。换句话说，我们将把图灵机的形式化视为一种编程语言，我们可以在其中编写程序。用这种语言编写的程序随后可以由一台通用图灵机（universal Turing machine）来解释——也就是说，用同一种语言编写的另一个程序。一个用某种语言编写的程序能够解释该语言中的任意其他程序，并不是什么新颖的想法——这正是经典“引导式”（bootstrapping）语言处理器方法的基础。但为了继续本书中的研究，我们有必要在图灵机的背景下精确地阐明这一点

    首先，我们需要提出一种通用的方式来描述图灵机，使得这些描述可以作为其他图灵机的输入。也就是说，必须定义一种语言，其字符串都是图灵机的合法表示形式。这个问题已经显现出来：无论我们为这种表示选择多么大的字母表，总会有图灵机的状态数和磁带符号数更多。因此，我们需要将状态和磁带符号编码为固定字母表上的字符串。我们采用如下约定：表示图灵机状态的字符串形式为 $\lbrace q\rbrace \lbrace 0,1\rbrace ^∗$，即字母 $q$ 后跟一个二进制字符串。类似地，磁带符号总是表示为形如 $\lbrace a\rbrace \lbrace 0,1\rbrace^∗$ 的字符串
    
    设 $M=(K,Σ,δ,s,H)$ 是一台图灵机，令 $i$ 和 $j$ 为最小整数，满足 $2^i \geqslant |K|$ 且 $2^j \geqslant |\Sigma| + 2$。那么 $K$ 中的每个状态都将表示为字母 $q$ 后跟一个长度为 $i$ 的二进制字符串；$Σ$ 中的每个符号也将以字母 $a$ 后跟一个 $j$ 位二进制字符串的形式表示。头的移动方向 $←$ 和 $→$ 也将被视为“荣誉磁带符号”（它们正是定义 $j$ 时“+2”项的原因）。我们规定特殊符号 $⊔$、$\rhd$、$←$ 和 $→$ 分别用字典序最小的四个符号来表示：
    
    1. $⊔$ 总是表示为 $a0^j$
    2. $\rhd$ 表示为 $a0^{j-1}1$
    3. $←$ 表示为 $a0^{j-2}10$
    4. $→$ 表示为 $a0^{j-2}11$
    5. 起始状态 $s$ 总是表示为字典序中第一个状态 $q0^i$
    
    注意，我们要求在符号 $a$ 和 $q$ 后的字符串前补零，以使总长度达到所需值
    
    我们将整个图灵机 $M$ 的表示记作 “$M$”。这个“$M$”由转移表 $δ$ 构成。也就是说，它是一系列形如 $(q,a,p,b)$ 的字符串序列，其中 $q$ 和 $p$ 是状态的表示，$a$ 和 $b$ 是符号的表示，各部分之间用逗号分隔，并包含在括号中。我们采用惯例：四元组按字典序递增排列，从 $δ(s,⊔)$ 开始。停止状态集合 $H$ 将通过间接方式确定：如果某个状态未出现在任何四元组的第一个分量中，则该状态属于停机状态。如果 $M$ 判定某种语言，因此 $H={y,n}$，我们将采用惯例：$y$ 是两个停机状态中字典序较小的那个
    
    通过这种方式，任何图灵机都可以被表示出来。我们将使用相同的方法来表示图灵机字母表中的字符串。任意字符串 $w∈Σ^∗$ 都将有一个唯一的表示，也记作 “$w$”，即其各个符号表示的拼接
    
    <figure markdown="span">
      ![Img 1](../../../img/computational_theory/ch5/computational_ch5_img1.png){ width="800" }
    </figure>
    
    现在我们已经准备好讨论一台通用图灵机 $U$，它使用其他机器的编码作为程序来指导其运行。直观上，$U$ 接受两个参数：一台机器 $M$ 的描述 “$M$”，以及一个输入字符串 $w$ 的描述 “$w$”。我们希望 $U$ 具有如下性质：当且仅当 $M$ 在输入 $w$ 上停机时，$U$ 在输入 “$M$”“$w$” 上才会停机。为了使用我们在上一章中为图灵机建立的功能性表示法，可以写成：$U(“M”“w”) = “M(w)”$
    
    我们实际上描述的并不是单磁带机器 $U$，而是一个与之密切相关的三磁带机器 $U'$（之后，$U$ 将是模拟 $U'$ 的单磁带图灵机）。具体来说，$U'$ 使用其三条磁带如下：第一条磁带包含当前被模拟的机器 $M$ 的磁带内容的编码；第二条磁带包含 $M$ 本身的编码；第三条磁带包含在模拟计算的当前步骤中 $M$ 的状态的编码。
    
    机器 $U'$ 以某个字符串 “$M$”“$w$” 作为其第一条磁带的输入，其余两条磁带为空。（如果输入字符串不是这种形式，$U'$ 的行为无关紧要。）首先，$U'$ 将 “$M$” 移动到第二条磁带上，并将 “$w$” 向左移动到第一条磁带的左端，前面加上符号 “$\rhd⊔$”。因此，在此时刻，第一条磁带的内容为 “$\rhd ⊔w$”。接着，$U'$ 在第三条磁带上写下 $M$ 的初始状态 $s$ 的编码，即始终为 $q0^i$（$U'$ 可以通过检查 “$M$” 轻松确定 $i$ 和 $j$）。现在，$U'$ 开始模拟 $M$ 的计算步骤。在每次模拟步骤之间，$U'$ 会将第二条和第三条磁带的读写头保持在最左端，而第一条磁带的读写头则扫描当前对应时刻 $M$ 所扫描符号的编码中的 $a$ 部分。
    
    $U'$ 模拟 $M$ 的一个步骤如下：它扫描第二条磁带，直到找到一个四元组，其第一个分量与第三条磁带上的编码状态匹配，且第二个分量与第一条磁带上扫描到的编码符号匹配。如果找到了这样的四元组，它就将状态更新为该四元组的第三个分量，并在第一条磁带上执行由第四个分量建议的操作。如果第四个分量编码的是 $M$ 的磁带字母表中的一个符号，则将该符号写入第一条磁带。如果第四个分量是 $a0^{j-2}10$（即 $←$ 的编码），则 $U'$ 将其第一条磁带的读写头向左移动到下一个 $a$ 符号；如果是 $a0^{j-2}11$（$→$ 的编码），则向右移动。如果遇到 $⊔$ 的编码，$U'$ 必须将其转换为 $a0^j$，即 $M$ 中空白符号的编码
    
    如果在某一步中，状态-符号组合在第二条磁带上未找到，这意味着该状态是一个停机状态。此时 $U'$ 也会进入相应的停机状态。至此，我们完成了对 $U'$ 运作方式的描述

## 3 The Halting Problem

!!! quote "课本原文 AI 翻译"

    假设你用自己最喜欢的编程语言编写了一个程序，它能完成一项非凡的壮举：该程序接收任意一个用相同语言编写的程序 $P$，以及该程序的一个输入 $X$。通过某种巧妙的分析，你的程序总能正确判断程序 $P$ 在输入 $X$ 上是否会停止（如果会，则返回“yes”），还是将永远运行下去（如果不会，则返回“no”）。你把这个程序命名为 `halts(P, X)`
    
    这是一个极其宝贵的程序。它可以发现各种微妙的错误，这些错误会导致其他程序在某些输入上无限运行。使用这个程序，你可以实现许多惊人的功能。这里是一个略显微妙的例子：你可以用它来编写另一个程序，名字叫 `diagonal(X)`
    
    ```c linenums="1"
    // diagonal(X)
    a: if halts(X, X) then goto a else halt
    ```
    
    注意 `diagonal(X)` 的作用：如果 `halts` 程序判断程序 `X` 在以自身作为输入时会停止，那么 `diagonal(X)` 就会无限循环；否则，它就会停止
    
    现在出现了一个无法回答的问题：`diagonal(diagonal)` 是否会停止？
    
    它停止当且仅当调用 `halts(diagonal, diagonal)` 返回“no”；换句话说，它停止当且仅当它不会停止。这是一矛盾：我们只能得出结论——最初假设的那个程序 `halts(P, X)` 是不存在的。也就是说，不可能存在任何程序、任何算法，能够解决“任意程序是否会在给定输入上停止”这一问题
    
    这种论证方式不仅来自你过去对计算机科学的学习，也来自二十世纪普遍文化中的经典悖论。关键在于，我们现在已经引入了所有必要的工具，来形式化、数学严谨地表达这个悖论。我们拥有了一种完整的算法形式化表示方法，一种“编程语言”式的工具：图灵机。事实上，在上一节中，我们引入了最后一个所需特性：我们已经构建了一个框架，使得我们的“程序”可以操作其他程序及其输入——这正是我们虚构的程序 `halts(P, X)` 所做的。因此，我们现在准备定义一个不可递归的语言，并证明它确实不可递归。令：$H=\lbrace“M”“w”:图灵机 M 在输入字符串 w 上停止\rbrace$
    
    首先注意到，$H$ 是递归可枚举的：它恰好是我们在上一节中介绍的通用图灵机 $U$ 所半判定的语言。事实上，当输入为 “$M$”“$w$” 时，$U$ 正好在输入属于 $H$ 时停止
    
    此外，如果 $H$ 是递归的，那么每一个递归可枚举语言都是递归的。换句话说，$H$ 是我们第 4.2 节所提出问题的关键：即所有递归可枚举语言是否也都是图灵可判定的——这个问题的答案是肯定的，当且仅当 $H$ 是递归的
    
    假设 $H$ 确实由某个图灵机 $M_0$ 判定。那么对于任意一个特定的图灵机 $M$，它半判定某个语言 $L(M)$，我们可以设计一台图灵机 $M'$ 来判定 $L(M)$，方法如下：首先，$M'$ 将其输入磁带从形式 $▹⊔w\underline{⊔}$ 转换为 $▹“M”“w”\underline{⊔}$，然后在该输入上模拟 $M_0$。根据假设，$M_0$ 将正确判断 $M$ 是否接受 $w$。我们可以这样说：所有递归可枚举语言都可以规约（reduce）到 $H$，因此 $H$ 是递归可枚举语言类中的完备语言（complete language）
    
    但我们可以通过形式化上面关于 `halts(P, X)` 的论证来证明：$H$ 不是递归的。首先，如果 $H$ 是递归的，那么 $H_1=\lbrace“M”:图灵机 M 在输入字符串 “M” 上停止\rbrace$ 也将是递归的（$H_1$ 对应于对角程序中 `halts(X, X)` 的部分）。如果存在一台图灵机 $M_0$ 能够判定 $H$，那么一台判定 $H_1$ 的图灵机 $M_1$ 只需要将其输入字符串 $▹⊔“M”\underline{⊔}$ 转换为 $▹⊔“M”“M”\underline{⊔}$，然后将控制权交给 $M_0$ 即可。因此，只需证明 $H_1$ 不是递归的就足够了
    
    其次，如果 $H_1$ 是递归的，那么它的补集也必然是递归的：$\bar{H_1}=\lbrace w:要么 w 不是图灵机的编码，要么它是某台图灵机 M 的编码 “M”，且 M 在输入 “M” 上不终止\rbrace$
    
    这是因为递归语言类在取补运算下是封闭的。顺便提一下，$\bar{H_1}$ 就是我们所谓的“对角语言”，它对应于我们之前构造的对角程序，也是整个证明的最后一步
    
    但 $H_1$ 不可能是递归可枚举的——更不用说递归了。假设存在一台图灵机 $M^*$ 半判定 $\bar{H_1}$。那么，$“M^*”$ 是否属于 $\bar{H_1}$？根据 $\bar{H_1}$ 的定义，$“M^*”$ 属于 $\bar{H_1}$ 当且仅当 $M^*$ 不接受输入字符串 $“M^*”$。但 $M^*$ 被假设为半判定 $\bar{H_1}$，因此 $“M^*”$ 属于 $\bar{H_1}$ 当且仅当 $M^*$ 接受 $“M^*”$。于是我们得出：$M^*$ 接受 $“M^*”$ 当且仅当它不接受 $“M^*”$。这是矛盾的，因此假设 $M_0$ 存在必须是错误的
    
    让我们总结本节的发展过程。我们试图探究：是否每一个递归可枚举语言都是递归的。我们观察到，这成立当且仅当那个特定的递归可枚举语言 $H$ 是递归的。从 $H$ 出发，我们通过两步推导出语言 $\bar{H_1}$，而为了使 $H$ 是递归的，$\bar{H_1}$ 必须是递归的。然而，假设 $\bar{H_1}$ 是递归的会导致逻辑矛盾，这是通过对角化方法得到的。因此，我们已经证明了以下最重要的定理

!!! tip "Theorem 5.3.1"

    语言 $H$ 不是递归的；因此，递归语言类是递归可枚举语言类的一个真子集

!!! quote "课本原文 AI 翻译"

    我们之前提到过，这个论证是第 1.5 节中用于证明 $2^N$ 不可数的对角化原理的一个实例。为了说明这一点，并再次强调证明的核心思想，我们定义一个在图灵机编码所用字母表上的字符串之间的二元关系 $R$：当且仅当 $u=“M”$，且存在一台图灵机 $M$ 接受 $w$ 时，有 $(u,w)∈R$（$R$ 是 $H$ 的一种形式化版本）
    
    现在，对于每个字符串 $u$，定义：$R_u = \lbrace w:(u,w)\in R \rbrace$（这些 $R_u$ 对应于递归可枚举语言）
    
    并考虑 $R$ 的对角线，即：$D = \lbrace w:(w,w) \notin R \rbrace$（$D$ 就是 $\bar{H_1}$）
    
    根据对角化原理，对所有 $u$ 都有 $D \not ={R_u}$；也就是说，$\bar{H_1}$ 是一个与任何递归可枚举语言都不同的语言
    
    为什么对任意 $u$ 都有 $D \not ={R_u}$？因为根据其构造，$D$ 与每一个 $R_u$（从而与每一个递归可枚举语言）在至少一个字符串上不同——即字符串 $u$ 本身
    
    定理 5.3.1 否定了我们在第 4.2 节末尾提出的两个问题中的第一个：“每一个递归可枚举语言是否也是递归的？”以及“递归可枚举语言类在取补运算下是否封闭？”
    
    但同样的证明也回答了第二个问题。显然，$H_1$ 像 $H$ 一样是递归可枚举的，而我们已经证明 $\bar{H_1}$ 不是递归可枚举的。因此，我们也证明了以下结论：

!!! tip "Theorem 5.3.2"

    递归可枚举语言类在取补运算下不封闭

## 4 Undecidable Problems About Turing Machine

!!! quote "课本原文 AI 翻译"

    我们已经证明了一个意义重大的结果。让我们稍作退后，从直观层面来理解这一结论，并结合丘奇-图灵论题（Church-Turing thesis）来看其含义。由于该证明表明语言 $H$ 不是递归的，而我们接受了“任何算法都可以转化为一台在所有输入上都能停机的图灵机”这一原则，因此我们可以得出结论：不存在一个算法，能够对任意给定的图灵机 $M$ 和输入字符串 $w$，判断 $M$ 是否接受 $w$
    
    对于那些不存在算法来解决的问题，我们称之为 **undecidable**（不可判定的）或 **unsolvable**（不可解的）；本章中我们将看到许多这样的问题。其中最著名、最基本的一个不可判定问题是：判断一台给定的图灵机在某个给定输入上是否会停机——我们刚刚证明了这个问题的不可判定性。这个问题通常被称为 **the halting problem for Turing machines**（图灵机的停机问题）
    
    需要注意的是，停机问题的不可判定性并不意味着在某些特定情况下无法预测图灵机是否会停机。例如，在例 4.1.2 中，我们能够推断出某台简单的机器在某个特定输入上必定不会停机。或者，我们可以检查图灵机的转移表，看看是否存在停机状态；如果不存在，则该机器在任何输入上都不会停机。这类更复杂的分析可能在某些特定情况下提供有用的信息；但我们的定理表明，任何此类分析最终要么无法完成，要么产生错误的结果：不存在一种完全通用的方法，能够正确地判断所有情况
    
    一旦我们通过对角化方法确立了停机问题是不可判定的，那么大量其他问题的不可判定性便随之而来。这些结果并非通过进一步的对角化证明，而是通过归约（reductions）来证明的：我们在每种情况下都证明，如果某个语言 $L_2$ 是递归的，那么另一个已知为非递归的语言 $L_1$ 也必须是递归的——这会导致矛盾，从而说明 $L_2$ 也不可能是递归的
    
    设 $L_1,L_2\subseteq \Sigma^*$ 是两个语言。从 $L_1$ 到 $L_2$ 的一个 **reduction** 是一个递归函数 $\tau:\Sigma^* \rightarrow \Sigma^*$，满足：当且仅当 $\tau(x) \in L_2$ 时，有 $x \in L_1$
    
    读者必须注意理解“归约方向”的含义。为了证明某个语言 $L_2$ 不是递归的，我们需要找到一个已知为非递归的语言 $L_1$，然后将 $L_1$ 归约到 $L_2$。如果反过来将 $L_2$ 归约到 $L_1$，那就毫无意义：它只能说明如果我们能判定 $L_1$，那么就能判定 $L_2$ ——但我们已经知道无法判定 $L_1$，因此这种归约无助于证明 $L_2$ 的不可判定性

!!! tip "Theorem 5.4.1"

    如果语言 $L_1$ 不是递归的，并且存在从 $L_1$ 到 $L_2$ 的规约，那么 $L_2$ 也不是递归的

!!! tip "Theorem 5.4.2"

    以下关于图灵机的问题都是不可判定的：

    1. 给定一个图灵机 $M$ 和一个输入字符串 $w$，$M$ 在输入 $w$ 上是否会停机？
    2. 给定一个图灵机 $M$，$M$ 在空带上是否会停机？
    3. 给定一个图灵机 $M$，是否存在某个字符串使得 $M$ 在其上会停机？
    4. 给定一个图灵机 $M$，$M$ 是否在所有输入字符串上都会停机？
    5. 给定两个图灵机 $M_1$ 和 $M_2$，它们是否在相同的输入字符串上停机？
    6. 给定一个图灵机 $M$，它半判定的语言是否是正则语言？是否是上下文无关语言？是否是递归语言？
    7. 此外，对于某个特定的固定图灵机 $M$，以下问题也是不可判定的：给定一个字符串 $w$，$M$ 是否在 $w$ 上停机？

## 7 Properties of Recursive Languages

!!! tip "Theorem 5.7.1"

    一个语言是递归的，当且仅当它本身及其补集都是递归可枚举的

!!! info "Definition 5.7.1"

    我们说图灵机 $M$ **enumerates**（枚举）语言 $L$，当且仅当存在 $M$ 的某个固定状态 $q$，使得 $L = \lbrace w:(s,\rhd\underline{\sqcup})\vdash^*_M(q,\rhd\underline{\sqcup}w)\rbrace$
    
    一个语言是 **Turing-enumerable**，当且仅当存在一台图灵机能够枚举它

!!! quote "课本原文 AI 翻译"

    也就是说，$M$ 从空白带开始运行，在计算过程中周期性地经过某个特殊状态 $q$（不是停机状态）。进入状态 $q$ 表示当前磁带上字符串属于语言 $L$；随后 $M$ 可以离开状态 $q$，并在之后再次进入该状态，此时磁带上可能是 $L$ 中的另一个成员。注意，$L$ 中的元素可以按任意顺序列出，并且允许重复

!!! tip "Theorem 5.7.2"

    一个语言是递归可枚举的，当且仅当它是图灵可枚举的

!!! info "Definition 5.7.2"

    设 $M$ 是一台枚举语言 $L$ 的图灵机。我们说 $M$ **lexicographically enumerates**（按字典序枚举）$L$，当且仅当以下条件成立，其中 $q$ 是特殊的显示状态：每当 $(q,\rhd\underline{\sqcup}w) \vdash^+_M(q,\rhd\underline{\sqcup}w')$，则 $w'$ 在字典序上大于 $w$。一个语言是 **lexicographically Turing-enumerable**（字典序图灵可枚举的），当且仅当存在一台图灵机能够按字典序枚举它

!!! tip "Theorem 5.7.3"

    一个语言是递归的，当且仅当它是字典序图灵可枚举的

!!! tip "Theorem 5.7.4 (Rice's Theorem)"

    假设 $C$ 是所有递归可枚举语言类的一个真子集，且非空。那么以下问题是不可判定的：给定一台图灵机 $M$，其识别的语言 $L(M)$ 是否属于 $C$？