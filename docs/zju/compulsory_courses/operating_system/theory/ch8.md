# 8 Main Memory

!!! tip "说明"

    本文档正在更新中……

!!! info "说明"

    本文档仅涉及部分内容，仅可用于复习重点知识

## 1 Background

程序（通常存储在磁盘等二级存储中）必须被加载到主内存中，并由操作系统为其创建一个进程上下文，才能被 CPU 执行。CPU 只能直接与主内存和其内部的寄存器进行数据交换。其他存储设备（如磁盘）的数据需要通过主内存中转

- 寄存器：位于 CPU 内部，访问速度最快（一个时钟周期或更短）
- 主内存：访问速度比寄存器慢得多，可能需要数十甚至数百个时钟周期。这造成了 CPU 速度和内存速度之间的鸿沟

为了弥补 CPU 和主内存之间的速度差距，在它们之间引入了高速缓存。缓存保存了最近使用的内存数据的副本，当 CPU 需要数据时，会先在高速缓存中查找，如果找到就可以快速获取，从而显著提高系统性能

在多道程序操作系统中，多个进程同时存在于内存中。为了防止一个进程意外或恶意地修改另一个进程或操作系统的内存空间，必须要有内存保护机制，以确保每个进程都能正确、安全地运行

<figure markdown="span">
    ![Img 1](../../../../img/operating_system/ch8/os_ch8_img1.png){ width="600" }
</figure>

Memory Wall：处理器（CPU）性能与动态随机存取存储器（DRAM）性能之间日益扩大的速度差距

<figure markdown="span">
    ![Img 2](../../../../img/operating_system/ch8/os_ch8_img2.png){ width="600" }
</figure>

!!! tip "base and limit registers"

    基址-界限寄存器保护机制：用于在多个进程同时运行时，保护进程彼此之间以及保护操作系统免受进程的干扰。它为每个进程提供一个独立的、受保护的逻辑地址空间

    - 基址寄存器：存放某个进程在物理内存中的起始地址
    - 界限寄存器：存放该进程逻辑地址空间的最大长度

    当 CPU 为一个用户进程生成一个内存地址（逻辑地址）时，在将该地址发送到内存总线之前，硬件会自动将逻辑地址与基址寄存器的值相加，得到物理地址。同时，硬件会检查这个逻辑地址是否小于界限寄存器的值。如果地址 >= 界限值，则会触发一个陷阱错误（通常是由于地址越界），操作系统会终止该进程

    <figure markdown="span">
        ![Img 3](../../../../img/operating_system/ch8/os_ch8_img3.png){ width="600" }
    </figure>

程序中的内存地址在从源代码到最终可执行文件的生成过程中，经历的三个不同表示阶段和绑定过程

1. symbolic address（符号地址）：存在于程序员编写的源代码中。地址使用易于人类理解和记忆的符号（标识符）表示，例如变量名、函数名等
2. relocatable address（可重定位地址）：由编译器（或汇编器）生成，存在于目标模块中。编译器将符号地址转换成一个相对于该目标模块起始地址的偏移量（例如，本模块内偏移 14 字节的位置）。这个步骤称为 **编译时绑定**
3. absolute address（绝对地址）：在程序被加载到内存准备执行之前形成，存在于最终的可执行文件或内存映像中。地址是具体的、最终的物理内存地址。这个转换由链接器（在链接多个目标模块时，进行 **链接时绑定**）或加载器（在将程序放入内存时，进行 **加载时绑定**）完成。它们将可重定位地址与已知的基址相结合，计算出绝对的物理地址。地址直接对应物理内存的一个单元

!!! tip "compiler, linker and loader"

    加载器：执行装载工作，是程序运行的最后一个步骤

    1. 输入：由链接器生成的可执行程序文件
    2. 输出：将程序置于内存中运行的进程
    3. 主要任务：将可执行文件中的代码和数据段从磁盘读取到内存中。为程序分配运行时所需的内存空间。根据可执行文件中的信息，完成最后的地址重定位。跳转到程序的入口点，开始执行程序

    <figure markdown="span">
        ![Img 4](../../../../img/operating_system/ch8/os_ch8_img4.png){ width="600" }
    </figure>

程序中的指令和数据在哪个时间点被分配（绑定）到具体的物理内存地址：

1. compile time（编译时期）：在程序编译期间。编译器必须提前知道进程将在内存中的哪个绝对地址开始驻留。编译器直接生成使用绝对物理地址的代码（绝对代码）。缺乏灵活性，如果程序的起始地址需要改变，必须重新编译整个程序
2. load time（装入时刻绑定）：在程序被加载到内存以准备执行时。编译时不知道程序将位于何处。编译器生成可重定位代码（其中的地址是相对于程序起始地址的偏移量）。当加载器将程序读入内存时，它根据当时分配给程序的实际物理起始地址，计算出所有地址的最终值。一旦加载完成，程序在内存中的位置就固定了。如果程序需要被换出后再换入，它通常必须回到同一个内存位置。比编译时绑定更灵活，因为无需重新编译，只需重新加载
3. execution time（执行时刻）：在程序正在运行时。进程在执行过程中可以被移动到不同的内存区域。这需要硬件支持，通常是内存管理单元（MMU），其核心组件就是 **基址和界限寄存器**。进程生成的地址是逻辑地址，CPU 在访问内存的每一个指令周期中，硬件 MMU 都会自动将逻辑地址与基址寄存器的值相加，转换为物理地址，如果进程被移动，操作系统只需更新该进程的基址寄存器即可。进程本身无需感知，也无需重新编译或重新加载。提供了最大的灵活性。这是现代通用操作系统（如 Windows, Linux, macOS）实现虚拟内存、进程切换和多道程序设计的基础

!!! tip "logical and physical address space"

    1. 逻辑地址空间：这是从正在运行的进程（CPU）视角看到的地址集合。进程认为它独占了从 0 开始一直到某个最大值的连续内存空间。这个地址是虚拟的，因为它不一定对应真实的物理内存位置。逻辑地址也称为虚拟地址
    2. 物理地址空间：这是物理内存硬件（RAM） 的真实地址集合。每一个物理地址对应一个实际的内存存储单元

    在 compile time 和 load time 绑定中：程序知道或者一旦确定就固定了自己在物理内存中的位置。因此，CPU 生成的地址（逻辑地址）直接就是内存单元要使用的地址（物理地址）。两者是相同的

    在 execution time 绑定中：CPU 生成的逻辑地址和最终送达内存总线的物理地址是不同的

    <figure markdown="span">
        ![Img 5](../../../../img/operating_system/ch8/os_ch8_img5.png){ width="600" }
    </figure>

!!! tip "MMU"

    **memory management unit**：核心功能是进行地址转换：将程序生成的虚拟地址（或逻辑地址）动态地映射或转换为内存硬件所使用的物理地址
    
    MMU 的工作机制（以基址寄存器方案为例）：

    1. relocation register（重定位寄存器）：这是 MMU 中的一个特殊寄存器，通常被称为 **基址寄存器**。当一个进程被调度执行时，操作系统会把这个进程在物理内存中的起始地址加载到这个寄存器中
    2. 地址转换过程：

        1. CPU 生成逻辑地址：用户程序在执行时，所有内存访问指令产生的都是逻辑地址
        2. MMU 介入：这个逻辑地址不会直接发送到内存总线，而是先被送到 MMU
        3. 加上基址：MMU 将重定位寄存器（基址寄存器）中的值与该逻辑地址相加，得到最终的物理地址
        4. 访问内存：计算出的物理地址被发送到内存总线，从而访问正确的物理内存单元

    用户程序完全在它自己的逻辑地址空间中运行，它认为内存就是从 0 开始的一片连续空间。程序无法感知也无法直接访问物理地址。它生成的所有地址都经过 MMU 的自动转换

## 2 Swapping

## 3 Contiguous Memory Allocation

## 4 Paging

## 5 Structure of The Page Table

## 6 Segmentation

## 7 Example: The Intel Pentium
