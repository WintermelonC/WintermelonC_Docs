# 10 File System Interface

!!! tip "说明"

    本文档正在更新中……

!!! info "说明"

    本文档仅涉及部分内容，仅可用于复习重点知识

<figure markdown="span">
    ![Img 1](../../../../img/operating_system/ch10/os_ch10_img1.png){ width="600" }
</figure>

## 1 File Concept

文件是操作系统管理的一种连续的逻辑地址空间，对用户和程序呈现为一个统一的整体。文件本质上是信息的序列，可以以位、字节、行或记录等形式组织。其具体含义和格式由文件的创建者与使用者决定，操作系统一般不解释其内容

文件类型：

1. 数据文件：存储用户或程序生成的数据。数值型，字符型，二进制型
2. 程序文件：存储计算机程序。源代码，目标代码，可执行文件

!!! tip "File Structure"

    1. none（无结构）：文件被视为一个没有内部逻辑划分的字节流或字序列。操作系统仅负责存储和检索这些字节，对其内容的任何解释（如格式、意义）完全由应用程序负责
    2. simple record structure（简单记录结构）：文件由一组记录组成，每条记录是一个逻辑单位

        1. 行：以换行符分隔的记录，常见于文本文件
        2. 固定长度记录：所有记录具有相同的字节数，易于定位
        3. 可变长度记录：记录长度不同，需要更复杂的管理来分隔记录

    3. complex structure（复杂结构）：文件具有特定的、可能很复杂的内部格式

        1. 格式化文档：如 Word 文档、PDF 文件，包含字体、排版等丰富信息
        2. 可重定位装入文件：如 .o 或 .obj 文件，包含可由链接器重新组织的机器代码和数据

    复杂的文件结构可以在无结构（字节流）的基础上实现。只需在字节流中定义和插入特殊的控制字符或标记，应用程序就能解释出记录或复杂格式。这提供了灵活性

    文件采用何种逻辑结构，取决于：

    4. 操作系统：操作系统内核或文件系统可能定义一些通用的基础结构
    5. 程序：大多数情况下，是应用程序决定如何解释文件中的字节序列，从而赋予文件具体的结构

!!! tip "File Attributes"
    
    1. name
    2. identifier：文件系统内部使用的唯一数字标识，用于在存储中精确定位文件，对用户透明
    3. type
    4. location
    5. size
    6. protection：定义访问权限（读、写、执行）及适用于哪些用户/组，是系统安全性的基础
    7. time，date，user identification：记录文件的创建、最后修改/访问时间及所有者，用于审计、追踪和系统管理

    所有这些属性信息（元数据）通常作为一个记录保存在目录结构中，而目录结构本身也存储在磁盘上，确保系统重启后仍可恢复

    !!! tip "File Type"

        MS-DOS / Windows（传统方式）：主要依赖文件扩展名

        <figure markdown="span">
            ![Img 2](../../../../img/operating_system/ch10/os_ch10_img2.png){ width="600" }
        </figure>

        MAC OS X（macOS）：历史上使用一种更丰富的元数据系统。每个文件除了数据外，还包含创建者属性，用于记录是哪个应用程序创建了该文件。这有助于系统快速找到并启动关联程序来打开文件。现代 macOS 也结合使用了扩展名和统一类型标识符

        UNIX / Linux：采用更底层、更可靠的 magic number 方法。魔数是保存在文件开头（文件头）的几个特定字节，它们像签名一样，唯一标识了该文件的格式。当系统需要判断文件类型时，它会读取文件开头的这些字节，并与已知的魔数表进行比对。这种方法不依赖于容易篡改的扩展名，因此更可靠

        <figure markdown="span">
            ![Img 3](../../../../img/operating_system/ch10/os_ch10_img3.png){ width="600" }
        </figure>

!!! tip "File Operations"

    文件是一种抽象数据类型 (ADT)。这意味着操作系统可以通过定义一组良好的操作（接口）来隐藏文件存储和管理的复杂细节，为用户和程序提供一个简洁、统一的逻辑视图

    1. create
    2. write：系统会维护一个当前文件位置指针来指示下一个写入操作发生的位置。写入后指针会自动更新
    3. read
    4. seek：在不进行读写的情况下，显式地移动当前文件位置指针到文件的指定位置。这允许随机访问文件内容
    5. delete
    6. truncate：删除文件的部分或全部内容
    7. open(Fi)：系统根据文件名 Fi 在磁盘上的目录结构中查找其对应的元数据条目，然后将这些信息加载到内存中的一个打开文件表条目中。这样做是为了避免后续每次操作都去访问较慢的磁盘。打开操作通常会返回一个文件描述符或句柄，供进程后续操作使用
    8. close(Fi)：将内存中保存的该文件的元数据写回磁盘的目录结构中，以确保持久化。同时释放内存中的相关资源

### 1.1 Open File

当进程成功调用 open() 系统调用打开一个文件后，操作系统会返回一个文件描述符或句柄。这个描述符本质上是一个指向内核 open-file table 某个条目的索引或指针。进程后续的所有文件操作（读、写、关闭等）都通过这个描述符来引用对应的打开文件信息

1. system-wide table（系统范围的打开文件表）：这是一个全局表，系统中所有进程共享。每个打开的文件在这里有且只有一个条目。它存储文件级的共享信息
2. per-process table（每个进程的打开文件表）：每个进程有自己独立的表。它存储进程特有的信息

操作系统在内存中为每个已打开文件维护的几类核心元数据：

1. file pointer：它是一个偏移量，指向文件中下一次读或写操作将要发生的位置。每个进程独立拥有。即使两个进程打开了同一个文件，它们各自拥有独立的文件指针，互不影响。这确保了进程对文件的操作（如顺序读写）是独立的
2. file-open count：一个计数器，记录当前有多少个进程打开了这个文件。全局共享。该计数保存在系统级的打开文件表中。当进程关闭文件时，计数减 1。只有当计数变为 0 时，操作系统才认为文件已完全关闭，此时可以安全地释放为该文件在内存中分配的所有资源
3. disk location of the file：这是文件数据在物理存储设备（如磁盘）上位置信息的缓存。它通常包含了指向文件数据块的指针。全局共享，缓存在系统级表中
4. access rights：记录了进程打开文件时请求的访问模式。按进程存储，保存在进程级的打开文件表中

open file locking（文件锁）：并非所有系统都支持，这通常是特定操作系统（如 Linux、Windows）及其文件系统提供的一项高级功能。作为仲裁者，在多进程并发访问文件的场景下，通过锁机制来协调访问顺序，确保数据操作的完整性

文件锁的类型类似于读写锁：

1. shared lock（reader，读锁）：允许多个进程同时获取并用于读取文件。当一个进程持有共享锁时，其他进程仍然可以获取共享锁进行读操作，但不能获得排他锁进行写操作
2. exclusive lock（writer，写锁）：一次只允许一个进程获取。用于写入文件。当一个进程持有排他锁时，其他进程既不能获取共享锁也不能获取排他锁，即完全独占访问

文件锁的执行模式：

1. mandatory（强制锁）：由操作系统内核强制执行。如果进程 A 持有了某个锁（如排他锁），那么进程 B 的任何违反锁规则的访问尝试（如试图读取被排他锁锁定的文件）将被操作系统直接阻止或返回错误
2. advisory（劝告锁）：操作系统只提供查询和设置锁的机制，但不强制阻止进程的 I/O 操作。进程在访问文件前，可以先劝告性地检查锁的状态。如果发现有冲突的锁，由进程自己决定是等待、放弃还是忽略锁直接进行访问

## 2 Access Methods

操作系统或文件系统中两种基本的文件数据访问模式：sequential access 和 direct / random access

### 2.1 Sequential Access

数据必须严格按照从前到后的线性顺序进行读取或写入，就像磁带机一样

1. read next：读取当前位置的数据，并将内部指针自动移动到下一个位置
2. write next：在当前位置写入数据，并将指针移动到下一个位置
3. reset：将当前位置指针移回文件的起始位置

不允许在最后一次写入之后直接读取：如果文件刚刚被写入了一些数据，在没有执行重置操作将指针移回文件开头（或某个已知位置）的情况下，立即尝试读下一个可能会失败或读取到无意义的数据。这是因为写入操作使指针停留在了文件末尾之后的位置

<figure markdown="span">
    ![Img 4](../../../../img/operating_system/ch10/os_ch10_img4.png){ width="600" }
</figure>

### 2.2 Direct Access

允许程序直接跳转到文件的任何位置进行读写操作，无需经过前面的数据，就像磁盘或内存访问一样

文件被逻辑上划分为固定大小的块或记录，n 表示第 n 个块

1. read n：直接读取第 n 个块的数据
2. write n：直接在第 n 个块的位置写入数据
3. position to n：将内部文件指针移动到第 n 个块的位置

    1. read next / write next：在定位操作之后，可以顺序地读取或写入后续的块

4. rewrite n：直接覆盖第 n 个块的数据。这是直接访问模式最有用的操作之一，可以修改文件中任意部分的内容，而无需重写整个文件

<figure markdown="span">
    ![Img 5](../../../../img/operating_system/ch10/os_ch10_img5.png){ width="600" }
</figure>

## 3 Directory Structure

1. index file（索引文件）：一种文件组织方式，其中通过一个单独的索引结构来记录文件中每个记录的位置，从而实现快速随机访问
2. relative file（相对文件，直接文件）：一种文件组织方式，其中记录通过相对记录号（RRN） 直接访问，记录号通常通过哈希函数从键值计算得出

<figure markdown="span">
    ![Img 6](../../../../img/operating_system/ch10/os_ch10_img6.png){ width="600" }
</figure>

目录是一个 symbol table（符号表）。就像编程中的符号表将变量名映射到内存地址一样，目录将用户友好的、人类可读的文件名映射到操作系统内部用于标识和管理文件的底层数据结构 —— file control block

文件控制块是操作系统内核中保存一个文件所有元数据（属性）的数据结构，如文件大小、位置、权限、时间戳等

从数据结构的角度看，目录本身是一个包含多条记录的集合。每个节点对应一个文件（或子目录），其中存储了该文件的管理信息。这些信息通常至少包括：文件名；指向文件控制块（FCB）的引用。因此，目录是文件系统元数据的组织框架，它不直接存储文件数据，而是存储如何找到和管理这些数据的索引或指针

<figure markdown="span">
    ![Img 7](../../../../img/operating_system/ch10/os_ch10_img7.png){ width="600" }
</figure>

<figure markdown="span">
    ![Img 8](../../../../img/operating_system/ch10/os_ch10_img8.png){ width="600" }
</figure>

对目录执行的操作：

1. search for a file
2. create a file
3. delete a file
4. list a directory：获取并显示目录中所有文件和子目录的列表
5. rename a file
6. traverse the file system：系统地访问文件系统中的每一个目录和文件。通常从根目录开始，递归地进入每个子目录

在文件系统设计中，对目录进行逻辑组织所要实现的三个核心目标：

1. efficiency：目录的组织方式应能使操作系统和用户快速找到所需文件
2. naming：目录系统应提供灵活、符合直觉的命名机制

    1. 不同文件可同名：在不同的目录（或对不同用户）中，允许使用相同的文件名。这避免了全局唯一命名带来的繁琐
    2. 同一文件可多名：通过硬链接（同一文件系统内）或符号链接/快捷方式（可跨文件系统）机制，允许一个文件拥有多个不同的路径名。这为用户提供了从不同逻辑视角访问同一文件的灵活性

3. grouping：目录结构应允许用户根据文件的属性、用途或项目将其逻辑地组织在一起

<figure markdown="span">
    ![Img 9](../../../../img/operating_system/ch10/os_ch10_img9.png){ width="600" }
</figure>

<figure markdown="span">
    ![Img 10](../../../../img/operating_system/ch10/os_ch10_img10.png){ width="600" }
</figure>

<figure markdown="span">
    ![Img 11](../../../../img/operating_system/ch10/os_ch10_img11.png){ width="600" }
</figure>

!!! tip "Tree-Structured Directories"

    每个目录条目中有一个特殊位（0 或 1），用于区分该条目是文件还是子目录

    层次结构允许使用路径名进行精确导航，减少搜索范围。自然地通过子目录组织相关文件，形成逻辑分组

    每个进程有一个当前工作目录，所有相对路径都从此处开始解析

    - 绝对路径：从根目录 `/` 开始的完整路径
    - 相对路径：相对于当前目录的路径

    创建文件是在当前目录中创建新文件

<figure markdown="span">
    ![Img 12](../../../../img/operating_system/ch10/os_ch10_img12.png){ width="600" }
</figure>

!!! tip "Acyclic-Graph Directories"

    无环图目录支持文件共享，允许一个文件有多个路径名（多个目录条目指向同一个文件），形成一个有向无环图

    别名问题：同一个文件可以有两个或多个不同的名称（路径），这在目录结构中称为 alias。这提供了灵活性，但也引入了管理复杂性

    悬空指针问题：假设文件 count 在目录 dict 和 spell 中都有条目。如果 dict 中的条目被删除，但文件本身可能还被 spell 引用。如果通过某个目录（如 dict）的链接删除文件本身，那么其他目录（如 spell）中指向该文件的链接就会变成悬空指针，指向一个已不存在的文件

    解决方案：维护反向指针列表。为每个文件维护一个列表，记录所有指向它的目录条目。这样，在删除文件时，可以先检查引用计数，或同时删除所有相关链接

    为了明确区分原始文件和它的别名，引入了 link 作为新的目录条目类型。link 本身是一个目录条目，但它不包含文件数据，只包含一个指针，指向另一个文件（或目录）的原始位置

    解析链接：当访问一个链接时，操作系统需要解析它，即跟随该指针找到实际的文件数据

    1. 硬链接：直接指向文件的文件控制块。删除原始文件后，硬链接仍然有效，直到所有硬链接都被删除
    2. 符号链接（软链接）：包含目标文件的路径字符串。如果原始文件被删除，符号链接将变为断开状态（悬空）

    无环图目录需要确保没有环
    
    <figure markdown="span">
        ![Img 13](../../../../img/operating_system/ch10/os_ch10_img13.png){ width="600" }
    </figure>

## 4 File System Mounting

## 5 File Sharing

## 6 Protection