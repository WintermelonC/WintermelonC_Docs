# 5 The Network Layer

!!! tip "说明"

    本文档正在更新中……

!!! info "说明"

    本文档仅涉及部分内容，仅可用于复习重点知识

## 1 Overview of Network Layer

- 网络层：负责将数据包从发送方（源主机）跨越多个网络路由到接收方（目的主机）。它关注的是端到端的通信，可能跨越多个不同的物理网络。IP 协议是这一层的核心
- 数据链路层：负责在同一个本地网络内（例如，同一个以太网、同一个 Wi-Fi 网络内），将帧从一个设备（节点）传送到另一个直接相连的设备。它关注的是单跳通信，即在单一网段或物理链路上的数据传输。可以理解为负责最后一公里（或第一公里）的传输，确保数据在相邻设备间可靠传递

网络层的两个核心功能：

1. **forwarding**（转发）：是路由器在收到一个数据包后所执行的即时动作。它查看数据包的目的地址，查询内部的转发表，然后决定该数据包应该从哪个具体的端口发送出去
2. **routing**（路由）：是决定数据包从源到目的地的整条路径的过程。它通过运行路由协议（如 OSPF, BGP）来收集网络信息，计算最佳路径，并最终生成和更新每个路由器里的转发表

> 路由过程负责生成和更新转发表；而转发过程则使用这张转发表来实际运送每个数据包。简单来说，路由是决策，转发是执行

网络层设计的两个基本出发点：

1. 对传输层的服务：网络层作为传输层的下层，需要为其提供服务。这里的关键设计抉择是提供面向连接的、可靠的虚电路服务（类似于电话系统），还是提供无连接的、尽最大努力交付的数据报服务（类似于邮政系统）。这个选择直接影响上层应用的开发
2. 网络的内部设计：这关乎如何在网络内部实现数据包的传输。是使用虚电路方式（在通信前先建立一条逻辑路径），还是使用数据报方式（每个数据包独立路由）。这个内部设计可以与提供给上层的服务相互独立

store-and-forward packet switching（存储转发式分组交换）：这是网络层（也是早期计算机网络）实现数据转发的基础性机制。其工作流程可以分解为以下步骤：

1. 接收与存储：当路由器从一条输入链路开始接收一个数据包时，它不会立即将正在接收的比特转发出去
2. 完整接收：路由器会等待，直到整个数据包的所有比特都到达，并将其临时存储（缓存） 在内存中
3. 处理与转发：在确认整个数据包已完整无误地到达后（例如，通过 CRC 校验），路由器才会查询其转发表，决定从哪条输出链路发送，然后开始将整个数据包转发到下一个节点

<figure markdown="span">
    ![Img 1](../../../img/computer_network/ch5/network_ch5_img1.png){ width="600" }
</figure>

网络层服务的三个基本原则，其核心思想是简化上层并保持通用性：

1. 独立性：网络层的服务不应该依赖于底层使用的特定路由器品牌或技术。这保证了上层应用能在各种硬件上运行
2. 透明性（屏蔽复杂性）：传输层（以及更上层的应用程序）不应该关心网络底层到底有多少路由器、它们是什么型号、或者它们是如何连接（拓扑）的。网络层负责处理所有这些复杂性，为上层提供一个清晰的抽象接口
3. 寻址一致性：整个网络应该使用一套统一的地址方案（如 IP 地址），这样任何主机都能用同样的方式寻址任何其他主机，无论它们位于网络的哪个位置

!!! tip "面向连接与无连接服务"

    - connection-oriented service：在发送数据之前，必须先通过信令建立一条确定的路径（虚电路）。所有数据包都按顺序沿着这条路径传输，传输结束后拆除连接。优点在于能提供有保证的服务质量
    - connectionless service：每个数据包（数据报）都独立携带完整的目的地址，每个路由器根据当前网络状况为每个包独立选择路径。数据包可能走不同的路径，也可能不按顺序到达。优点是更健壮、更简单、无需建立连接的开销

在无连接服务中，网络层从传输层接收到数据后，会将其封装成独立的 **datagram**（数据报）。每个数据报都包含完整的目的地址。在发送数据之前，不需要像打电话一样先建立一条端到端的路径。每个数据报在网络中都是独立的个体。路由器会为每一个经过的数据报单独进行路由决策，即使它们属于同一个通信流。由于网络状况实时变化，同一源和目的地的不同数据报可能会通过不同的路径传输，从而导致乱序到达

**forwarding table**（转发表）是路由器进行转发决策的路线图。索引键是数据包的目的地址；对应值是为了到达该目的地，应该使用的输出接口或线路

<figure markdown="span">
    ![Img 2](../../../img/computer_network/ch5/network_ch5_img2.png){ width="600" }
</figure>

在面向连接服务中，在通信开始之前，会先建立一条穿越网络的虚电路。这是一条预定义的路径，不同于物理电路，它是逻辑上的。每个数据包不再需要携带完整的目的地地址。取而代之的是，它只携带一个简短的连接标识符（例如，一个虚拟电路号或标签）。这个标识符在每段链路上是局部的，只在两个相邻路由器之间有意义。路由器根据数据包到达的输入接口和包内的标识符，结合其转发表，决定将其从哪个输出接口转发出去，并通常会将标识符替换为下一段链路使用的新的标识符

!!! tip "MPLS（多协议标签交换）"

    MPLS 是一种高性能的隧道技术，在 IP 网络之上提供面向连接的转发
    
    路由器 A 为不同的连接分配不同的标识符，即使这些连接可能使用同一条虚电路。路由器可以根据这些标识符对数据进行不同的优先级处理或路由
    
    <figure markdown="span">
        ![Img 3](../../../img/computer_network/ch5/network_ch5_img3.png){ width="600" }
    </figure>

| | 数据报网络（无连接）| 虚电路网络（面向连接）|
| -- | -- | -- |
| **电路建立** | 不需要 | 必需 |
| **寻址** | 每个数据包都包含完整的源地址和目的地址 | 每个数据包包含一个简短的虚电路(VC)号 |
| **状态信息** | 路由器不保存连接的状态信息 | 每条虚电路都需要在路由器中占用每连接的表项空间 |
| **路由** | 每个数据包被独立路由 | 在虚电路建立时选择路由；所有数据包都遵循此路由 |
| **路由器故障的影响** | 没有影响，除了在故障期间丢失的数据包 | 所有经过故障路由器的虚电路都将被中断 |
| **服务质量** | 困难 | 如果能为每条虚电路预先分配足够的资源，则很容易实现 |
| **拥塞控制** | 困难 | 如果能为每条虚电路预先分配足够的资源，则很容易实现 |

## 2 Routing Algorithms

网络层的根本任务是实现数据包从源头到目的地的路径选择与传输

路由器两大功能：

1. forwarding：根据数据包的目标地址查询内部的路由表，然后立即将数据包发送到正确的出站接口
2. 路由表维护：路由表是转发决策的依据。路由器需要动态地学习和更新路由信息，以确保表中的路径是准确和最新的。这个过程通常由路由协议和算法完成

路由算法上下文：

1. datagram 网络：每个数据包都是独立处理的。网络状况可能实时变化，因此同一个会话的不同数据包可能会通过不同的路径传输
2. virtual circuit 网络：在通信开始前，会预先建立一条固定的路径。一旦虚电路建立成功，所有后续数据包都沿着这条预定路径传输，直到连接结束

优秀路由算法的目标：correctness, simplicity, robustness, stability, fairness and efficiency

!!! tip "基于计算路径时拥有的网络信息范围的分类"

    1. global routing algorithm：每个路由器都拥有整个网络的完整拓扑信息和链路成本。它基于这张全局地图来独立计算到所有目的地的最佳路径

        - Link-state（LS）algorithm：每个路由器向网络中的所有其他路由器广播其邻居和链路成本信息。通过收集这些信息，每个路由器都能构建出完整的网络拓扑图，然后使用像Dijkstra算法这样的方法来计算最短路径。适用于小规模网络

    2. decentralized routing algorithm（分散式路由算法）：路由器不掌握全局网络信息。它只与直接相连的邻居路由器交换信息，并通过多次迭代和协作，逐步学习并计算出到达目的地的路径

        - distance-vector（DV）algorithm：每个路由器维护一个到所有已知目的地的距离向量。它定期与邻居交换自己的距离向量，并根据从邻居那里获得的信息来更新自己的路由表。适用于大规模网络

!!! tip "基于路径是否随时间动态调整的分类"

    1. static routing algorithm：路由是固定不变的，不会根据网络流量或拓扑的变化而自动调整。由网络管理员手动配置路由表。简单，开销小。无法适应网络故障或拥塞，缺乏灵活性
    2. dynamic routing algorithm：路由是自适应的。路由器会运行路由协议，根据收到的网络变化信息（如链路故障、成本变化）动态地重新计算和更新路由表。能够适应网络变化，提供更好的性能和可靠性。更复杂，会消耗带宽和 CPU 资源，并且可能引入路由环路（数据包在路由器间循环转发）和路由振荡（路由频繁剧烈变化）等问题

### 2.1 Link State Routing Algorithm

LS 算法的基本前提是，网络中的每个路由器（节点）都掌握着整个网络的完整地图。这张地图包含了所有路由器、连接它们的链路以及每条链路的成本

如何构建全局视图：链路状态广播。每个路由器首先识别所有与它直接相连的邻居，并测量到达每个邻居的链路成本。路由器将这一局部信息（即它的链路状态）打包成一个链路状态包，并将这个包广播（洪泛）到网络中的所有其他路由器。通过这个过程，每个路由器最终都会收到来自网络中所有其他路由器的链路状态包。通过整合这些信息，每个路由器就能在本地独立地构建出一张完整、一致的网络拓扑图

> 互联网中广泛使用的 OSPF 协议就是一个典型的链路状态路由协议

当每个路由器都拥有了完整的网络拓扑图后，它们就可以在本地运行相同的路径计算算法，而不会相互通信。这个算法就是著名的 Dijkstra 最短路径算法。该算法以一个特定的路由器作为源节点，计算出从这个源节点到网络中所有其他目的节点的最短路径（最低成本路径）

算法的主要目标是找到从源节点到目标节点的最短路径。这里的最短并非单指物理距离，而是指综合成本最低

1. number of hops：跳数
2. delay
3. distance
4. bandwidth
5. communication cost
6. average traffic：平均流量

最优性原理：如果路由器 B 在从路由器 A 到路由器 C 的最优路径上，那么从 B 到 C 的最优路径也遵循同一路由

!!! tip "Sink Tree"

    对于网络中任何一个给定的目的地节点，将所有能到达该目的地的最短路径合并在一起，所形成的一个树形结构，就称为该目的地的汇点树

    > 也存在 source tree（源点树）

    <figure markdown="span">
        ![Img 15](../../../img/computer_network/ch5/network_ch5_img15.png){ width="600" }
    </figure>
    
汇点树的结构带来了两个至关重要的简化：

1. 基于目的地的转发：数据包本身只需要携带最终目的地的地址。路由器在转发时，无需知道数据包的完整路径，也无需关心源地址。它只需要根据数据包的目的地地址，在本地查找应该将其发送给哪个邻居（下一跳）即可。这使得转发决策变得非常简单和高效
2. 下一跳转发：每个路由器在转发数据包时，只需要负责将其送到通往目的地的路径上的下一个路由器，而不需要直接送达最终目的地

具体体现就是转发表（路由表）。每一个条目的结构是：目的地地址 → 下一跳地址

??? example "Dijkstra 示例"

    <figure markdown="span">
        ![Img 16](../../../img/computer_network/ch5/network_ch5_img16.png){ width="600" }
    </figure>

Dijkstra 算法复杂度：$O(n^2)$

!!! tip "Oscillation Problem"

    路由振荡问题：所有路由器对于到达某个目的地的最佳路径无法稳定下来，而是发生持续、频繁的来回切换的现象

    原因：

    1. 动态的、与负载相关的链路成本：链路的成本不是固定的，而是由该链路上的实时流量负载决定的
    2. 所有路由器同步计算：网络中的所有路由器在同一时刻（或几乎同一时刻）运行路由算法，收集链路状态，并计算新的最短路径

    <figure markdown="span">
        ![Img 17](../../../img/computer_network/ch5/network_ch5_img17.png){ width="600" }
    </figure>

    > 就是两个人走路的时候面对面碰到了，默契的你往左、我往右，结果永远错不开

### 2.2 Distance Vector Routing Algorithm

DV 算法的特性：

1. distributed：没有路由器拥有整个网络的全局视图。每个路由器只与它直接相连的邻居路由器进行通信。路由器从邻居那里获取信息，在本地进行计算，然后将计算结果（即自己的距离向量）告知邻居。决策是基于局部信息协作完成的
2. iterative：路径计算不是一步完成的，而是通过多次重复的信息交换-计算-再交换过程逐步逼近正确结果。路由器会周期性地与邻居交换信息，或者在外界条件（如链路成本变化、链路故障）触发时进行交换。每次交换后都可能重新计算路由。这个过程一直持续到网络中所有路由器的最佳路径信息都稳定下来，不再变化为止，此时算法自行终止
3. asynchronous（异步）：路由器之间不需要一个统一的全局时钟来协调动作。每个路由器可以独立地在任意时间点启动计算、发送或接收信息。这种松耦合的设计使算法更具鲁棒性，能够更好地适应现实网络中节点和链路状态变化的不确定性

使用 DV 算法的路由协议：

1. RIP：一个在中小型企业内部网络中常用的内部网关协议，是 DV 算法的经典实现
2. BGP：互联网的骨干路由协议，用于在不同自治系统之间交换路由信息。它作为一种路径向量协议，是 DV 算法的一种增强和演变，通过记录完整路径来解决 DV 算法的一些固有缺陷（如环路问题）

!!! tip "Bellman-Ford Equation"

    令 $d_x(y)$ 表示从节点 $x$ 到节点 $y$ 的最低成本路径的成本。那么，这些最低成本通过著名的贝尔曼-福特方程相互关联，即：

    $d_x(y) = \min\limits_v \lbrace c(x,v)+d_v(y) \rbrace$

    1. $d_x(y)$：这是我们要求解的值
    2. $\min\limits_v$：这个符号表示我们要在所有可能的选项中找到一个最小值。这里，我们是在遍历节点 $x$ 的每一个直接邻居 $v$
    3. $c(x,v)$：这是从节点 $x$ 到其邻居 $v$ 的直接链路成本。这是一个已知的、可测量的值
    4. $d_v(y)$：节点 $x$ 自己并不知道这个值，它需要从邻居 $v$ 那里学习这个信息
    
    <figure markdown="span">
        ![Img 18](../../../img/computer_network/ch5/network_ch5_img18.png){ width="600" }
    </figure>

每个节点 $x$ 开始时都有一个 $D_x(y)$，这是它自己到每个节点 $y$ 的最低成本路径成本的估计值。每个节点 $x$ 的 $D_x$ 记录了它认为自己到达网络中每一个其他节点的距离（成本）

每个路由器需要在其本地存储和维护以下三类信息：

1. 到直接邻居的链路成本 $c(x,v)$：这是唯一精确的、通过直接测量可知的信息。路由器知道连接到它每个直接邻居的链路成本
2. 自身的距离向量 $D_x$：这是该路由器当前的路由表或路由视图。它基于目前从邻居那里学到的最新信息，给出了到达所有目的地的最佳成本估计。这个向量会根据收到的邻居信息持续更新
3. 每个邻居的距离向量 $D_y$：路由器通过定期与邻居交换信息，来获取每个邻居的距离向量。拥有了邻居的距离向量，节点 $x$ 就能通过 Bellman-Ford Equation 得到 $d_x(y)$，进而得到完整的距离向量

由于可能不止有一个邻居，节点会选择最小的那个作为距离向量 $D_x(y)$。这时，如果自己的路由信息发生变化，节点会将自己的新距离向量广播给所有直接邻居，整个网络继续计算最后收敛

<figure markdown="span">
    ![Img 19](../../../img/computer_network/ch5/network_ch5_img19.png){ width="600" }
</figure>

!!! tip "Count-to-Infinity Problem"

    算法虽然在理论上能保证收敛，但收敛速度可能极慢。在某些情况下，特别是发生链路故障时，正确路由信息在网络中传播的速度远远慢于错误信息的扩散，导致路由器在较长时间内保持错误的路由状态

    > 假设路由器 A 到达网络 X 的路径中下一跳是 B。当 A 与 X 之间的直连链路突然故障，A 会立刻知道。但如果 B 在此之前曾通过 A 学习过到达 X 的路径，那么 B 会认为“我可以经 A 到达 X”。链路故障后，A 会告诉 B “我到 X 的距离是无穷大”，但 B 可能会告诉 A “别担心，我有一条到 X 的路径（成本是 2）”。A 一听，就会认为“太好了，那我可以通过 B 到达 X，成本是 1 + 2 = 3”，并更新自己的路由表。然后 A 会把这个“新发现”的路径（成本 3）通告给 B。B 收到后，会更新自己的路径为“经 A 到达 X，成本是 1 + 3 = 4”，并再次通告给 A…… 如此循环，A 和 B 会不断地、缓慢地依次增加它们到 X 的成本估计值（3, 4, 5, 6...），就像在“计数”一样，直到这个成本最终增加到某个预先定义的“无穷大”值（例如在 RIP 中是 16），它们才会意识到目的地 X 是不可达的
    >
    > 这 78 AB

!!! tip "LS vs DV"

    1. 消息复杂度

        1. LS：高开销。每个路由器都需要将描述其本地链路状态的报文广播（洪泛） 给网络中的所有其他路由器。对于一个有 $n$ 个节点的网络，最坏情况下每个链路状态更新都会产生 $O(nE)$ 的消息量
        2. DV：低开销。路由器只与直接邻居交换它们的整个距离向量（路由表）。消息不会传播到整个网络，因此初始开销和微小变化时的开销通常更低

    2. 收敛速度

        1. LS：较快。使用 Dijkstra 算法，时间复杂度为 $O(n^2)$
        2. DV：较慢且不确定。因为路由信息是从邻居开始一跳一跳地逐步传播的，收敛速度通常比 LS 慢。其最严重的问题是 Count-to-Infinity，在发生某些故障时，收敛时间会变得非常长，期间可能导致路由环路

    3. 健壮性

        1. LS：更健壮。每个节点都有自己的网络视图，不依赖于邻居的计算结果。产生错误也很会被限制在本地，不会传播到其他路由器中
        2. DV：较不健壮。一个节点的错误信息会被邻居接收，邻居会基于此错误信息进行错误计算，然后这个错误会进一步传播给邻居的邻居，从而污染网络中大范围的路由表

    LS 通过更高的通信开销换取了更快的收敛和更好的健壮性，适用于现代中大型网络（如 OSPF）

    DV 则以较慢的收敛和较差的错误容忍度为代价，提供了简单的实现和较低的开销，适用于较小或简单的环境（如 RIP）

### 2.3 Hierarchical Routing



## 3 The Network Layer in The Internet

### 3.1 The IPv4 Datagram

报头结构：

1. 固定部分：长度为 20 字节，包含 IP 数据报必须的基本字段
2. 可选部分：长度可变，用于存放额外的控制信息

采用大端序网络字节顺序。数据比特的传输方向：先从左到右，再从上到下。这种顺序确保了不同系统间数据解释的一致性

<figure markdown="span">
    ![Img 4](../../../img/computer_network/ch5/network_ch5_img4.png){ width="600" }
</figure>

!!! tip "Version"

    1. 4 bit
    2. 功能：标识 IP 协议版本（IPv4 为 4，IPv6 为 6）
    3. 意义：允许网络在长期内平滑过渡到新版本协议，实现向后兼容

!!! tip "IHL"

    Internet Header Length

    1. 4 bit
    2. 计量单位：以 32 位字（4 字节）为单位计算首部长度
    3. 计算方式：实际字节数 = IHL 值 × 4 字节
    4. 取值范围：最小 5（20 字节），最大 15（60 字节）
    5. 实际应用：由于选项字段很少使用，绝大多数 IP 数据报的 IHL 值为 5，即标准的 20 字节首部

!!! tip "Different Service"

    Type of Service

    1. 8 bit
    2. 高 6 位：定义数据包的服务质量等级，允许网络设备根据应用需求提供不同的处理优先级
    3. 低 2 位：用于网络拥塞时的显式拥塞通知
    4. 应用示例：实时流量（IP 电话），非实时流量（FTP）

!!! tip "Total Length"

    1. 16 bit
    2. 功能：定义整个 IP 数据报（首部 + 数据）的总长度
    3. 数值范围：0-65535 字节
    4. 实际上常见值 ≤ 1500字节，因为数据报大小通常受限于以太网的 MTU（最大传输单元）1500 字节，以避免在链路层进行分片，提高传输效率

!!! tip "Identification"

    1. 16 bit
    2. 功能：唯一标识一个数据报的所有分片，同一个原始数据报的所有分片共享相同的标识值

!!! tip "DF and MF"

    DF（Don't Fragment）：设置为 1 时，指示路由器不要对该数据报进行分片，如果数据报超过路径 MTU 且 DF 位被设置，路由器将丢弃该数据报并返回错误信息。用于路径 MTU 发现机制

    MF（More Fragment）：设置为 1 时，表示后面还有更多分片，最后一个分片的 MF 位设置为 0，表示分片结束

!!! tip "Fragment Offset"

    1. 13 bit
    2. 功能：指示当前分片在原始数据报中的位置（以 8 字节为单位）
    3. 计算：实际字节偏移量 = 偏移值 × 8
    4. 限制：最大 8192 个分片（由于 13 位字段最大值为 8191）

!!! tip "Time to Live"

    TTL

    1. 功能：防止数据报在网络中无限循环
    2. 工作机制：初始由源主机设置一个值（通常为 64、128 等），每经过一个路由器，值减 1，当 TTL 值为 0 时，路由器丢弃数据包并发送 ICMP 超时消息给源主机
    3. 实际意义：虽然名为生存时间，但实际上是通过跳数限制来控制数据包的生命周期

!!! tip "Protocol"

    1. 8 bit
    2. 核心功能：指定传输层协议类型，实现网络层到传输层的多路复用
    3. 常见协议编号：6：TCP（传输控制协议），面向连接的可靠传输；17：UDP（用户数据报协议），无连接的不可靠传输
    4. 协议号：连接网络层和传输层，确保数据被正确传递给相应的传输层协议
    5. 端口号：连接传输层和应用层，确保数据被正确传递给目标应用程序

!!! tip "Header Checksum"

    1. 功能：检测 IP 首部在传输过程中是否发生错误
    2. 计算方法：将整个 IP 首部按 16 位（2 字节）分段，使用反码运算对所有 16 位字段进行求和，结果取反得到校验和值
    3. 验证过程：接收方将收到的首部（包括校验和字段）按同样方法计算，如果结果不为零，说明首部在传输中出错
    4. 逐跳更新：由于 TTL 字段每经过路由器都会减 1，选项字段也可能改变，因此每个路由器都必须重新计算校验和
    5. 仅保护首部：不保护数据部分，数据完整性由更高层协议（如 TCP）负责

!!! tip "Source Address and Destination Address"

    1. 各 32 bit（4 字节）
    2. 源地址：标识发送数据报的主机
    3. 目的地址：标识接收数据报的目标主机
    4. 重要性：这两个字段是 IP 路由的基础，决定了数据报从源到目的地的传输路径

!!! tip "Options"

    这是 IP 首部的可变长度部分，用于提供额外的控制功能：

    1. 安全选项：定义数据报的安全等级和保密要求（实际中很少使用）
    2. 严格源路由：由发送方指定数据报必须经过的精确路径（每个路由器地址）
    3. 松散源路由：只指定必须经过的某些关键路由器，其余路径由网络决定
    4. 记录路由：每个处理数据报的路由器都会在选项中添加自己的 IP 地址，用于路径跟踪
    5. 时间戳：路由器不仅记录地址，还记录处理时间，用于网络性能分析

    特点：

    1. 选项字段长度可变，最大 40 字节
    2. 实际网络中选项使用较少，因为会增加路由器处理负担
    3. 许多防火墙会拒绝带选项的数据报

!!! tip "Data"

    payload，有效负荷

    包含实际要传输的高层协议数据（如 TCP 段、UDP 数据报、ICMP 消息等）。长度可变，受限于 IP 数据报总长度（最大 65535 字节）和 MTU 限制。是 IP 协议真正要传送的有用信息

### 3.2 Packet Fragmentation

不同网络技术的最大有效负荷：

1. 以太网：1500 字节（最常见的 MTU 值）
2. 802.11 无线网络：2304 字节（加密前的最大帧大小）
3. IP 协议理论最大值：65515字节（总长度 65,355 减去 20 字节 IP 首部）

解决 MTU 不匹配的两种方案：

1. 避免分片：使用路径 MTU 发现机制，源主机探测到目的地的整条路径上最小的 MTU，然后发送不超过该大小的数据包
2. 接受分片：在需要时进行分片传输。存在两种重组策略

    1. transparent fragmentation：在分片发生后，由网络中的路由器负责重组，对端主机不可见
    2. nontransparent fragmentation：分片一直保持到目的主机，由最终接收方负责重组

!!! tip "Transparent Fragmentation"

    分片在网络内部（路由器）进行，重组也在网络内部（出口路由器）完成，最终主机看到的是完整的数据包，对分片过程无感知

    存在的问题：

    1. 分片完整性识别问题：出口路由器需要确知是否已收到全部分片

        - 解决方案：需要一个计数字段（记录总分片数量）或者一个结束标志位（如 IP 协议的 MF 位，当 MF = 0 时，说明是最后一个分片）

    2. 路由路径限制问题：所有分片必须经过同一个出口路由器。这违反了网络层的无状态设计原则，限制了负载均衡能力，降低了网络路由的灵活性，如果某个分片选择不同路径，重组将失败

    <figure markdown="span">
        ![Img 5](../../../img/computer_network/ch5/network_ch5_img5.png){ width="600" }
    </figure>

!!! tip "Nontransparent Fragmentation"

    在需要分片的网络节点（路由器）进行分片，仅在最终目的主机进行重组，路由器只负责转发分片，不进行重组操作

    优势：

    1. 降低路由器负担：路由器无需维护分片状态信息
    2. 提高网络灵活性：不同分片可以经过不同的网络路径

    IPv4 实现这种策略：同一数据报的所有分片共享相同标识值，Fragment Offset 字段指示分片在原始数据报中的位置，MF 字段标记是否为最后一个分片。通过这些字段的组合，目的主机能够正确重组原始数据报

    <figure markdown="span">
        ![Img 6](../../../img/computer_network/ch5/network_ch5_img6.png){ width="600" }
    </figure>

<figure markdown="span">
    ![Img 7](../../../img/computer_network/ch5/network_ch5_img7.png){ width="600" }
</figure>

!!! tip "Path MTU Discovery"

    路径 MTU 发现机制

    路径 MTU 是指从源到目的地整条路径上能够传输的最大数据包大小，这是路径上所有链路 MTU 的最小值

    工作原理：源主机首先发送一个较大的数据包（通常设置 DF 不分片标志），如果中间路由器的 MTU 小于数据包大小，会丢弃数据包并返回 ICMP 需要分片错误消息，源主机根据返回的 MTU 信息减小数据包大小，重复此过程直到找到合适的路径 MTU

    优势：避免分片（源端发送合适大小的数据包，避免中间节点分片）、动态适应（能够适应网络拓扑和 MTU 的变化）、提高效率

    劣势：增加启动延迟（需要多次尝试-错误过程才能确定最佳 MTU）

    <figure markdown="span">
        ![Img 8](../../../img/computer_network/ch5/network_ch5_img8.png){ width="600" }
    </figure>

### 3.3 IPv4 Addressing

IPv4 地址结构：

1. 总长度：32 位二进制数，通常表示为点分十进制（如 192.168.1.1）
2. 分层设计：包含网络部分和主机部分，与平坦的 MAC 地址形成鲜明对比

IP 地址标识的是网络接口，而非整台计算机，多宿主主机（连接多个网络）需要多个 IP 地址，路由器作为网络互联设备，必然拥有多个 IP 地址

IPv4 地址表示方法：

1. dotted decimal notation：将 32 位地址分成 4 个 8 位组，每组转换为十进制数。每个数字范围 0-255（对应 8 位二进制）
2. 十六进制表示：将 32 位地址直接转换为 8 位十六进制数

prefix：共享相同高位比特的连续地址块。通常写作网络地址/前缀长度（如 192.168.1.0/24）

<figure markdown="span">
    ![Img 9](../../../img/computer_network/ch5/network_ch5_img9.png){ width="600" }
</figure>

<figure markdown="span">
    ![Img 10](../../../img/computer_network/ch5/network_ch5_img10.png){ width="600" }
</figure>

#### 3.3.1 Subnets

传统 IP 编址中，一个网络号对应一个物理网络。但当组织规模扩大时，单个大型网络会面临广播风暴，管理困难等问题

解决方案是进行子网划分：将一个大的 IP 地址块在内部逻辑上划分为多个子网络，每个子网有自己的子网标识，对外部网络仍显示为统一的网络地址

<figure markdown="span">
    ![Img 11](../../../img/computer_network/ch5/network_ch5_img11.png){ width="600" }
</figure>

在划分子网的网络中，主路由器需要确定将入境数据包转发到哪个具体的子网

1. 基于主机的路由表：维护一个庞大的路由表，为网络内每个主机地址单独指定出口线路。缺点是路由表规模庞大，占用大量内存
2. 基于子网掩码的智能路由（实际采用方案）：使用按位与运算进行子网匹配，找到匹配的子网并转发

!!! tip "Classful Addressing"

    分类寻址是在 CIDR 技术出现之前的，将 IP 地址预先划分为几个固定类别

    <figure markdown="span">
        ![Img 12](../../../img/computer_network/ch5/network_ch5_img12.png){ width="600" }
    </figure>

    B 类网络对大多数组织来说太大，C 类又太小

!!! tip "Allocating Public IP Addresses"

    1. 顶层机构：ICANN（互联网名称与数字地址分配机构），非营利组织，负责全球互联网标识符的协调管理，核心职责：IP 地址分配 + DNS 根服务器管理
    2. 区域性互联网注册机构（RIRs）：ARIN 北美地区，RIPE NCC 欧洲、中东和中亚地区，APNIC 亚太地区，LACNIC 拉丁美洲和加勒比地区，AfriNIC 非洲地区
    3. 本地组织：互联网服务提供商、大型企业等
    4. 终端用户：通过 DHCP 协议动态获取或静态配置 IP 地址

!!! tip "Classless InterDomain Routing"

    CIDR：无类别域间路由

    随着互联网快速增长，核心路由器需要维护的路由表条目数量急剧增加，严重影响网络性能

    解决方案：

    1. subnetting（子网划分）：将大的 IP 地址块划分为更小的子网
    2. route aggregation（路由聚合）：将多个连续的小地址块合并为一个大的地址前缀

    <figure markdown="span">
        ![Img 13](../../../img/computer_network/ch5/network_ch5_img13.png){ width="600" }
    </figure>

前缀重叠：不同的路由条目可能匹配同一个目标 IP 地址。决策规则：选择匹配的所有路由中前缀长度最长的那条

> 假设目标 IP 为 192.168.1.5，路由表中有：192.168.0.0/16、192.168.1.0/24、192.168.1.0/28。路由器将选择 192.168.1.0/28，因为它的前缀最长，路由最具体

!!! tip "Subnetting vs. Aggregation"

    两者都能减少路由表规模，提高网络效率，优化 IP 地址空间利用率

    子网划分：

    1. 企业内部网络分段
    2. 部门间网络隔离
    3. 提高地址利用效率

    聚合：

    1. ISP 向上游路由通告
    2. 减少核心路由表条目
    3. 提高路由收敛速度

<figure markdown="span">
    ![Img 14](../../../img/computer_network/ch5/network_ch5_img14.png){ width="600" }
</figure>

特殊 IP 地址：

1. `0.0.0.0`：默认地址

    1. 使用场景：系统启动过程中或网络配置时
    2. 作为源地址：表示本主机
    3. 作为目标地址：表示本网络中的所有主机
    4. 实际应用：DHCP 客户端在获取 IP 前使用该地址

2. `255.255.255.255`：有限广播地址

    1. 功能：本地网络广播
    2. 范围：仅在发送主机所在的物理网络段内有效
    3. 用途：网络发现协议，DHCP 客户端寻找服务器，本地网络管理

3. `127.0.0.1`：环回地址

    1. 地址范围：127.0.0.0/8（127.0.0.1 - 127.255.255.254）
    2. 功能：本地环回测试
    3. 特性：数据包不进入物理网络，直接返回给发送主机，用于测试网络协议栈是否正常工作
    4. 常见用途：开发和测试网络应用程序

#### 3.3.2 NAT

## 4 MPLS