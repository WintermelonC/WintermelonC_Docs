# 12 Concurrency Control

!!! tip "说明"

    本文档正在更新中……

!!! info "说明"

    本文档仅涉及部分内容，仅可用于复习重点知识

## 1 Lock-Based Protocols

数据项可以通过两种模式加锁：

1. exclusive mode（排他锁，X 锁）：当一个事务需要修改数据时使用，它会阻止其他事务同时读取或修改相同数据
2. shared mode（共享锁，S 锁）：当多个事务只需要读取数据时使用，允许多个事务同时获取读锁，但会阻止任何事务获取写锁

锁管理机制：系统有一个专门的并发控制管理器负责接收和处理锁请求，事务必须等待直到获得所需锁才能继续操作

Lock-compatibility matrix：

<figure markdown="span">
  ![Img 1](../../../img/database/ch12/database_ch12_img1.png){ width="400" }
</figure>

1. 如果一个数据项上的请求锁与其他事务已持有的锁兼容，则该事务可以获取该锁
2. 多个事务可以同时持有 S 锁；但如果任一事务持有 X 锁，则其他事务不能再获取任何类型的锁（无论是 S 锁还是 X 锁）
3. 如果锁无法立即授予（由于不兼容），请求锁的事务必须等待，直到其他事务释放所有不兼容的锁，然后才能获取该锁

locking protocol（锁协议）：所有事务在请求和释放锁时必须遵循的一组规则。锁协议通过限制可能的调度方式来确保并发执行的正确性

### 1.1 Pitfalls of Lock-Based Protocols

<figure markdown="span">
  ![Img 2](../../../img/database/ch12/database_ch12_img2.png){ width="400" }
</figure>

上述情况称为 deadlock（死锁）

1. 互斥条件：锁的排他性导致资源独占
2. 占有并等待：事务持有锁的同时请求新锁
3. 非抢占条件：已获得的锁不能被强制剥夺
4. 循环等待：形成等待环路

处理死锁需要回滚其中一个事务并释放其持有的锁

大多数锁协议都存在死锁的可能性。死锁是一种难以避免的弊端

如果并发控制管理器设计不当，还可能发生 starvation（饥饿现象）：

1. 某个事务可能正在等待获取数据项上的 X 锁，而同时其他一系列事务却不断获取该数据项上的 S 锁
2. 同一事务因反复陷入死锁而被多次回滚

通过合理设计，并发控制管理器（concurrency control manager）可以预防饥饿现象的发生

### 1.2 The Two-Phase Locking Protocol

保证 conflict-serializable schedules 的锁协议

1. Growing Phase：transaction 获得锁而不释放锁

    1. 获得 lock-S
    2. 获得 lock-X
    3. 将 lock-S 转换到 lock-X（upgrade）

2. Shrinking Phase：transaction 释放锁而不获得锁

    1. 释放 lock-S
    2. 释放 lock-X
    3. 将 lock-X 转换到 lock-S（downgrade）

两阶段锁协议不能完全避免死锁

在两阶段锁协议下可能出现级联回滚。为避免这种情况，可以采用改进版的 strict two-phase locking（严格两阶段锁协议），要求事务持有的所有 **排他锁** 必须保持到事务提交或中止时才释放

Rigorous two-phase locking（严谨两阶段锁协议）更为严格：要求所有锁（包括 **共享锁**）都保持到事务提交或中止。该协议下事务可按提交顺序实现串行化

### 1.3 Implementation of Locking

1. lock manager 可作为独立进程实现，事务向其发送加锁和解锁请求
2. 锁管理器通过发送授权消息响应请求（若发生死锁则发送回滚消息）
3. 请求事务将等待直至收到响应
4. 锁管理器维护称为 lock table 的数据结构，记录已授权锁和待处理请求
5. 锁表通常实现为内存哈希表，以被锁数据项名称作为索引键

<figure markdown="span">
  ![Img 3](../../../img/database/ch12/database_ch12_img3.png){ width="600" }
</figure>

### 1.4 Graph-Based Protocols

Graph-based protocols 是两阶段锁协议的替代方案

tree protocol 是最简单的 graph protocol

核心优势：

1. 死锁免疫：通过树形访问顺序自然避免循环等待
2. 弹性锁释放：事务可以在使用完父节点后立即释放其锁，而不必像 2PL 那样保持到事务结束
3. 高并发性：早期锁释放减少了资源占用时间

主要局限：

1. 恢复难题：由于允许早期解锁，可能出现事务 T2 读取了 T1 修改但未提交的数据，若 T1 最终中止会导致不可恢复的情况
2. 过度加锁：为访问节点 D，事务必须按 A → C → D 路径加锁，即使只需要访问 D
3. 协议互斥性：与 2PL 存在调度能力差异

#### 1.4.1 Tree Protocol

<figure markdown="span">
  ![Img 4](../../../img/database/ch12/database_ch12_img4.png){ width="600" }
</figure>

1. 只允许使用排他锁（X 锁）
2. 事务 Ti 的第一个锁可以加在任何数据项上。后续对数据项 Q 加锁的前提是：Ti 当前正持有 Q 的父节点的锁（也就是遵循父到子的路径）
3. 数据项可以在任何时候解锁
4. 如果数据项已被 Ti 加锁并解锁，则 Ti 后续不能再重新对其加锁

<figure markdown="span">
  ![Img 5](../../../img/database/ch12/database_ch12_img5.png){ width="800" }
</figure>

## * 2 Timestamp-Based Protocols

## * 3 Validation-Based Protocols

## 4 Multiple Granularity

## * 5 Multiversion Schemes

## 6 Deadlock Handling

## 7 Insert and Delete Operations

## * 8 Concurrency in Index Structures