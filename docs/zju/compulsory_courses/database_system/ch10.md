# 10 Query optimization

!!! tip "说明"

    本文档正在更新中……

!!! info "说明"

    本文档仅涉及部分内容，仅可用于复习重点知识

## 1 Introduction

evaluation plan（评估计划）明确定义了每个操作使用什么算法，以及如何协调操作的执行

cost-based query optimization（基于成本的查询优化）步骤：

1. 使用等价规则生成逻辑上等价的表达式
2. 注释结果表达式以获得替代查询计划
3. 基于估计成本选择最经济的计划

成本估算基础：

1. 关系统计信息（如记录数、属性不同值数量）
2. 中间结果统计
3. 算法成本公式

## 2 Transformation of Relational Expressions

两个关系代数表达式等价，当且仅当它们在所有符合数据库约束的实例上产生完全相同的元组集合（顺序无关）

> 如果数据库违反完整性约束导致结果不同，我们不予考虑

在 SQL 中，输入和输出是元组的多重集（允许重复元组）。在多重集关系代数中，若两个表达式在所有合法数据库实例上生成相同的多重集元组，则称它们等价

equivalence rule（等价规则）：两种形式的表达式可以相互替换

### 2.1 Equivalence Rules

1. conjunctive selection 操作可分解为一系列单个选择操作的序列：$\sigma_{\theta_1 \land \theta_2}(E) = \sigma_{\theta_1}(\sigma_{\theta_2}(E))$
2. selection 是 commutative（可交换的）：$\sigma_{\theta_1}(\sigma_{\theta_2}(E)) = \sigma_{\theta_2}(\sigma_{\theta_1}(E))$
3. projection 操作序列中仅需保留最后一个，其余可省略：$\Pi_{L_1}(\Pi_{L_2}(...(\Pi_{L_n}(E))...)) = \Pi_{L_1}(E)$
4. selection 操作可以与 cartesian products 和 theta 连接结合

    1. $\sigma_{\theta}(E_1 \times E_2) = E_1 \Join_{\theta} E_2$
    2. $\sigma_{\theta_1}(E_1 \Join_{\theta_2} E_2) = E_1 \Join_{\theta_1 \land \theta_2} E_2$

5. theta 连接操作（及 natural join）是 commutative：$E_1 \Join_{\theta} E_2 = E_2 \Join_{\theta} E_1$
6. 连接操作的可结合性

    1. natural join 是 associative（可结合的）：$(E_1 \Join E_2) \Join E_3 = E_1 \Join (E_2 \Join E_3)$
    2. theta join 在以下情况下是可结合的：$(E_1 \Join_{\theta_1} E_2) \Join_{\theta_2 \land \theta_3} E_3 = E_1 \Join_{\theta_1 \land \theta_3} (E_2 \Join_{\theta_2} E_3)$，其中 $\theta_2$ 仅涉及 $E_2$ 和 $E_3$ 的属性

7.  selection 操作在以下情况下可分配到 theta 连接操作中（先连接后选择 → 先选择后连接）

    1. 当选择条件 $\theta_0$ 仅涉及连接表达式之一 $E_1$ 的属性时：$\sigma_{\theta_0}(E_1 \Join_{\theta}E_2) = (\sigma_{\theta_0}(E_1)) \Join_{\theta}E_2$
    2. 当选择条件 $\theta_1$ 仅涉及 $E_1$ 的属性，且 $\theta_2$ 仅涉及 $E_2$ 的属性时：$\sigma_{\theta_1 \land \theta_2}(E_1 \Join_{\theta} E_2) = (\sigma_{\theta_1}(E_1)) \Join_{\theta} (\sigma_{\theta_2}(E_2))$

8.  projection 操作在 theta join 运算中的分配律（先连接后投影 → 先投影后连接）

    1. 如果连接条件 $\theta$ 仅涉及 $L_1 \cup L_2$ 中的属性：$\Pi_{L_1 \cup L_2}(E_1 \Join_{\theta} E_2) = (\Pi_{L_1}(E_1)) \Join_{\theta} (\Pi_{L_2}(E_2))$
    2. 对于连接 $E_1 \Join_{\theta} E_2$

        1. 设 $L_1$ $L_2$ 分别来自 $E_1$ $E_2$ 的属性集
        2. 设 $L_3$ 是 $E_1$ 中参与连接条件 $\theta$ 但不在 $L_1 \cup L_2$ 中的属性
        3. 设 $L_4$ 是 $E_2$ 中参与连接条件 $\theta$ 但不在 $L_1 \cup L_2$ 中的属性
        4. $\Pi_{L_1 \cup L_2}(E_1 \Join_{\theta} E_2) = \Pi_{L_1 \cup L_2}((\Pi_{L_1 \cup L_3}(E_1)) \Join_{\theta} (\Pi_{L_2 \cup L_4})(E_2))$

9. 集合 union 和 intersection 是 commutative
10. 集合 union 和 intersection 是 associative
11. selection 对并、交、差集具有分配律

    1. $\sigma_{\theta}(E_1 - E_2) = \sigma_{\theta}(E_1) - \sigma_{\theta}(E_2)$，对并集和交集同样成立
    2. 特殊情况：$\sigma_{\theta}(E_1 - E_2) = \sigma_{\theta}(E_1) - E_2$，对交集同样成立，但对并集不成立

12. projection 对并集具有分配律：$\Pi_{L}(E_1 \cup E_2) = (\Pi_{L}(E_1)) \cup (\Pi_L(E_2))$

<figure markdown="span">
  ![Img 1](../../../img/database/ch10/database_ch10_img1.png){ width="600" }
</figure>

**Example**：find the names of all instructors in the Music department, along with the titles of the courses that they teach

$\Pi_{name, title}(\sigma_{dept\_name = "Music"}(instructor \Join (teaches \Join \Pi_{course\_id, title}(course))))$

根据 7a，$\Pi_{name, title}((\sigma_{dept\_name = "Music"}(instructor) \Join (teaches \Join \Pi_{course\_id, title}(course))))$

==尽早地进行 selection 操作可以减少连接时 relation 的大小==

---

**Example**：Find the names of all instructors in the Music department who have taught a course in 2009, along with the titles of the courses that they taught

$\Pi_{name, title}(\sigma_{dept\_name = "Music" \land year = 2009}(instructor \Join (teaches \Join \Pi_{course\_id, title}(course))))$

根据 6a，$\Pi_{name, title}(\sigma_{dept\_name = "Music" \land year = 2009}((instructor \Join teaches) \Join \Pi_{course\_id, title}(course)))$

接着又可以拆分 $\sigma_{dept\_name = "Music"}(instructor) \Join \sigma_{year = 2009}(teaches)$

<figure markdown="span">
  ![Img 2](../../../img/database/ch10/database_ch10_img2.png){ width="600" }
</figure>

---

**Example**：$\Pi_{name, title}(\sigma_{dept\_name = "Music"}(instructor) \Join teaches) \Join \Pi_{course\_id, title}(course)$

根据 8a 和 8b，$\Pi_{name, title}(\Pi_{name, course\_id}(\sigma_{dept\_name = "Music"}(instructor) \Join teaches)) \Join \Pi_{course\_id, title}(course)$

==尽早地进行 projection 操作可以减少连接时 relation 的大小==

---

**Example**：如果 $r_2 \Join r_3$ 非常大而 $r_1 \Join r_2$ 小，我们选择 $(r_1 \Join r_2) \Join r_3$

==连接的顺序对于减少临时变量有影响==

---

**Example**：$\Pi_{name, title}(\sigma_{dept\_name = "Music"}(instructor) \Join teaches) \Join \Pi_{course\_id, title}(course)$

最好先进行 $\sigma_{dept\_name = "Music"}(instructor) \Join teaches$

### 2.2 Enumeration of Equivalent Expressions

查询优化器使用等价规则系统性地生成与给定表达式等价的表达式

生成所有等价表达式的方法如下：

1. 重复以下步骤：

    1. 对所有已发现的等价表达式中的每个子表达式，应用所有适用的等价规则
    2. 将新生成的表达式添加到等价表达式集合中

2. 直到不再产生新的等价表达式为止

上述方法在空间和时间上的开销非常大，两种优化方法：

1. 基于转换规则的优化计划生成
2. 针对仅包含选择、投影和连接查询的特殊情况处理方法

## 3 Statistics for Cost Estimation

基本关系统计量：

1. $n_r$：关系 r 中的元组数量
2. $b_r$：包含关系 r 元组的磁盘块数量
3. $l_r$：关系 r 中单个元组的大小（字节数）
4. $f_r$：关系 r 的块因子，即一个磁盘块能容纳的 r 的元组数量

属性级统计量：$V(A, r)$ 关系 r 中属性 A 的不同取值数量，等同于 ∏ₐ(r) 的大小

存储计算公式：当关系 r 的元组物理上连续存储时：$b_r = \lceil \dfrac{n_r}{f_r} \rceil$

### 3.1 Histograms

1. Equi-width 直方图
2. Equi-depth 直方图

### 3.2 Selection Size Estimation

$\sigma_{A=v}(r)$：

1. 满足条件的记录数估计：$\dfrac{n_r}{V(A, r)}$
2. 如果是主键属性上的等值条件：结果大小估计 = 1

$\sigma_{A\leqslant v}(r)$

1. 设 c 为满足条件的元组估计数
2. 若目录中有 $min(A, r)$ 和 $max(A, r)$

    1. 当 $v < min(A, r)$ 时，c = 0
    2. 否则：$c = n_r \dfrac{v - min(A, r)}{max(A, r) - min(A, r)}$

#### 3.2.1 Size Estimation of Complex Selections

**selectivity**（选择度）：指关系中元组满足某个条件的概率。如果关系 r 中有 $sᵢ$ 个元组满足条件 $θᵢ$，则该条件的选择度为 $sᵢ/nᵣ$

1. conjunction：假设条件间独立，估计公式为 $n_r \dfrac{s_1 s_2 \cdots s_n}{n_r^n}$
2. disjunction：$n_r (1 - (1 - \dfrac{s_1}{n_r})(1 - \dfrac{s_2}{n_r})\cdots(1 - \dfrac{s_n}{n_r}))$
3. negation：$n_r - size(\sigma_{\theta}(r))$

### 3.3 Estimation of the Size of Joins

1. Cartesian product r x s：包含 $n_r \times n_s$ 个元组，每个元组占 $l_r + l_s$ 字节
2. 当 $R∩S=∅$ 时，$r \Join s$ 等价于 r x s
3. 若 $R∩S$ 是关系 R 的主键：关系 s 的每个元组最多匹配关系 r 的一个元组，连接结果元组数 ≤ s 的元组数
4. 若 $R∩S$ 是关系 S 的外键且引用关系 R：连接结果元组数 = s 的元组数
5. 当 $R∩S=\{A\}$ 且 A 不是 R 或 S 的键时

    1. 假设 R 的每个元组都会与 S 的元组连接，结果大小估计为：$\dfrac{n_r \times n_s}{V(A, s)}$
    2. 若反过来假设 S 的每个元组与 R 连接，则估计为：$\dfrac{n_r \times n_s}{V(A, r)}$
    3. 取两个估计值中较小的一个通常更准确

### 3.4 Size Estimation for Other Operations

1. Projection：$\Pi_A(r) = V(A, r)$
2. Aggregation：$A_gf(r) = V(A, r)$
3. outer join

    1. 左外连接 = 内连接部分 + 左表中未匹配部分
    2. 全外连接 = 内连接部分 + 左表未匹配部分 + 右表未匹配部分

4. set 运算

    1. 同一关系的选择操作可以合并条件
    2. 不同关系的运算：

        1. 估计 r ∪ s 的大小 = r 的大小 + s 的大小
        2. 估计 r ∩ s 的大小 = r 和 s 大小的最小值
        3. 估计 r - s 的大小 = r 的大小
        4. 这三种估计可能不太准确，但提供了大小的上界

### 3.5 Estimation of Number of Distinct Values

Selections：$\sigma_{\theta}(r)$

1. 当条件强制属性 A 等于某个特定值 (如 A = 3) 时：结果中该属性只有一个唯一值，所以 $V(A, σ_θ(r)) = 1$
2. 当条件限定属性 A 为一组离散值 (如 A = 1 或 3 或 4) 时：不同值数量就是条件中指定的不同值的数量
3. 当条件是A与某值的比较 (如 A > 5，A ≠ 10等) 时：估计不同值数量为原关系的不同值数量乘以选择性，$V(A, σ_θ(r)) = V(A, r) * s$（选择性 s 表示满足条件的元组比例 (0 ≤ s ≤ 1)）
4. 其他情况：采用保守估计：取原关系不同值数量和结果集大小的较小值，$min(V(A, r), n_{σ_θ(r)})$

Join：$r \Join s$

1. 如果属性集 A 中的属性全部来自关系 r：$V(A, r ⋈ s) = min(V(A, r), n_{r ⋈ s})$
2. 如果属性集 A 包含来自 r 的属性 A1 和来自 s 的属性 A2：$V(A, r ⋈ s) = min(V(A1, r)*V(A2-A1, s), V(A1-A2, r)*V(A2, s), n_{r ⋈ s})$

Projection：$∏A(r)$ 中属性的不同值数量与 r 中相同

Aggregation：与投影操作相同

1. 对于 min(A) 和 max(A)：估计为 $min(V(A, r), V(G, r))$，其中 G 表示分组属性
2. 对于其他聚合函数（如 sum, avg, count 等）：假设所有值都不同，使用 $V(G, r)$ 作为估计值

### 3.6 Evaluation plan

执行计划的选择：

1. 选择执行计划时必须考虑不同评估技术之间的相互作用：独立为每个操作选择最便宜的算法可能无法得到最佳整体方案，例如：

    - 归并连接 (Merge-join) 可能比哈希连接 (Hash-join) 代价更高，但能产生有序输出，从而降低外层聚合操作的成本
    - 嵌套循环连接 (Nested-loop join) 可能支持流水线操作

2. 实际的查询优化器通常结合以下两种主要方法：

    1. 基于成本的搜索：搜索所有可能的计划并选择成本最低的方案
    2. 启发式方法：使用启发式规则选择执行计划

#### 3.6.1 Cost-Based Optimization

考虑为关系表达式 $r_1 \times r_2 \times \cdots \times r_n$ 寻找最优连接顺序的问题

该表达式存在 $\dfrac{2(n - 1)!}{(n - 1)!}$ 种不同的连接顺序

解决方案：无需生成所有连接顺序。采用动态规划方法：对任何子集只需计算一次最低成本连接顺序，存储计算结果供后续使用

## * 4 Dynamic Programming for Choosing Evaluation Plans



## * 5 Additional Optimization Techniques